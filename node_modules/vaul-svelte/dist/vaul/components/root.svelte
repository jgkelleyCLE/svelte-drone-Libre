<script>import { Dialog as DialogPrimitive } from "bits-ui";
import { setCtx } from "../ctx.js";
import { get } from "svelte/store";
export let open = false;
export let onOpenChange = void 0;
export let closeThreshold = void 0;
export let scrollLockTimeout = void 0;
export let snapPoints = void 0;
export let fadeFromIndex = void 0;
export let openFocus = void 0;
export let onOutsideClick = void 0;
export let closeOnOutsideClick = true;
export let backgroundColor = "black";
export let nested = false;
export let shouldScaleBackground = false;
export let activeSnapPoint = void 0;
export let onActiveSnapPointChange = void 0;
export let onRelease = void 0;
export let onDrag = void 0;
export let onClose = void 0;
export let dismissible = void 0;
export let direction = "bottom";
const {
  states: {
    keyboardIsOpen,
    activeSnapPoint: localActiveSnapPoint,
    drawerId,
    openDrawerIds,
    isOpen
  },
  methods: { closeDrawer, openDrawer },
  options: { dismissible: localDismissible },
  updateOption
} = setCtx({
  defaultOpen: open,
  defaultActiveSnapPoint: activeSnapPoint,
  onOpenChange: ({ next }) => {
    if (open !== next) {
      onOpenChange?.(next);
      open = next;
    }
    return next;
  },
  onActiveSnapPointChange: ({ next }) => {
    if (next === void 0 && snapPoints && activeSnapPoint !== next) {
      const newNext = snapPoints[0];
      onActiveSnapPointChange?.(newNext);
      activeSnapPoint = newNext;
      return newNext;
    }
    if (activeSnapPoint !== next) {
      onActiveSnapPointChange?.(next);
      activeSnapPoint = next;
    }
    return next;
  },
  closeThreshold,
  scrollLockTimeout,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  snapPoints,
  fadeFromIndex,
  nested,
  onDrag,
  onClose,
  onRelease,
  shouldScaleBackground,
  backgroundColor,
  dismissible,
  direction
});
$:
  activeSnapPoint !== void 0 && localActiveSnapPoint.set(activeSnapPoint);
$:
  updateOption("closeThreshold", closeThreshold);
$:
  updateOption("scrollLockTimeout", scrollLockTimeout);
$:
  updateOption("snapPoints", snapPoints);
$:
  updateOption("fadeFromIndex", fadeFromIndex);
$:
  updateOption("openFocus", openFocus);
$:
  updateOption("shouldScaleBackground", shouldScaleBackground);
$:
  updateOption("backgroundColor", backgroundColor);
$:
  updateOption("dismissible", dismissible);
$:
  updateOption("direction", direction);
$:
  open && !$isOpen && openDrawer();
$:
  !open && $isOpen && closeDrawer();
</script>

<DialogPrimitive.Root
	{closeOnOutsideClick}
	closeOnEscape={false}
	bind:open
	preventScroll={false}
	onOpenChange={(o) => {
		onOpenChange?.(o);
		if (!o) {
			closeDrawer();
		} else if (o) {
			openDrawer();
		}
	}}
	onOutsideClick={(e) => {
		if (!closeOnOutsideClick) return;

		onOutsideClick?.(e);

		if (e?.defaultPrevented) return;

		if ($keyboardIsOpen) {
			keyboardIsOpen.set(false);
		}
		e.preventDefault();
		if (!$localDismissible) {
			return;
		}
		const $openDialogIds = get(openDrawerIds);
		const isLast = $openDialogIds[$openDialogIds.length - 1] === get(drawerId);
		if (isLast) {
			onOpenChange?.(false);
			closeDrawer();
		}
	}}
	{...$$restProps}
>
	<slot />
</DialogPrimitive.Root>

<style>
	:global([data-vaul-drawer]) {
		touch-action: none;
		transition: transform 0.5s cubic-bezier(0.32, 0.72, 0, 1);
	}

	:global([data-vaul-drawer][data-vaul-drawer-direction="bottom"]) {
		transform: translate3d(0, 100%, 0);
	}

	:global([data-vaul-drawer][data-vaul-drawer-direction="top"]) {
		transform: translate3d(0, -100%, 0);
	}

	:global([data-vaul-drawer][data-vaul-drawer-direction="left"]) {
		transform: translate3d(-100%, 0, 0);
	}

	:global([data-vaul-drawer][data-vaul-drawer-direction="right"]) {
		transform: translate3d(100%, 0, 0);
	}

	:global(.vaul-dragging .vaul-scrollable [data-vaul-drawer-direction="top"]) {
		overflow-y: hidden !important;
	}

	:global(.vaul-dragging .vaul-scrollable [data-vaul-drawer-direction="bottom"]) {
		overflow-y: hidden !important;
	}

	:global(.vaul-dragging .vaul-scrollable [data-vaul-drawer-direction="left"]) {
		overflow-x: hidden !important;
	}
	:global(.vaul-dragging .vaul-scrollable [data-vaul-drawer-direction="right"]) {
		overflow-x: hidden !important;
	}

	:global([data-vaul-drawer][data-vaul-drawer-visible="true"][data-vaul-drawer-direction="top"]) {
		transform: translate3d(0, var(--snap-point-height, 0), 0);
	}

	:global(
			[data-vaul-drawer][data-vaul-drawer-visible="true"][data-vaul-drawer-direction="bottom"]
		) {
		transform: translate3d(0, var(--snap-point-height, 0), 0);
	}

	:global([data-vaul-drawer][data-vaul-drawer-visible="true"][data-vaul-drawer-direction="left"]) {
		transform: translate3d(var(--snap-point-height, 0), 0, 0);
	}

	:global([data-vaul-drawer][data-vaul-drawer-visible="true"][data-vaul-drawer-direction="right"]) {
		transform: translate3d(var(--snap-point-height, 0), 0, 0);
	}

	:global([data-vaul-overlay]) {
		opacity: 0;
		transition: opacity 0.5s cubic-bezier(0.32, 0.72, 0, 1);
	}

	:global([data-vaul-overlay][data-vaul-drawer-visible="true"]) {
		opacity: 1;
	}

	:global([data-vaul-drawer]::after) {
		content: "";
		position: absolute;
		background: inherit;
		background-color: inherit;
	}

	:global([data-vaul-drawer][data-vaul-drawer-direction="top"]::after) {
		top: initial;
		bottom: 100%;
		left: 0;
		right: 0;
		height: 200%;
	}

	:global([data-vaul-drawer][data-vaul-drawer-direction="bottom"]::after) {
		top: 100%;
		bottom: initial;
		left: 0;
		right: 0;
		height: 200%;
	}

	:global([data-vaul-drawer][data-vaul-drawer-direction="left"]::after) {
		left: initial;
		right: 100%;
		top: 0;
		bottom: 0;
		width: 200%;
	}

	:global([data-vaul-drawer][data-vaul-drawer-direction="right"]::after) {
		left: 100%;
		right: initial;
		top: 0;
		bottom: 0;
		width: 200%;
	}

	:global(
			[data-vaul-overlay][data-vaul-snap-points="true"]:not(
					[data-vaul-snap-points-overlay="true"]
				):not([data-state="closed"])
		) {
		opacity: 0;
	}

	:global(
			[data-vaul-overlay][data-vaul-snap-points-overlay="true"]:not(
					[data-vaul-drawer-visible="false"]
				)
		) {
		opacity: 1;
	}

	/* This will allow us to not animate via animation, but still benefit from delaying
	unmount via Bits */
	@keyframes -global-fake-animation {
		from {
		}
		to {
		}
	}

	@media (hover: hover) and (pointer: fine) {
		:global([data-vaul-drawer]) {
			-webkit-user-select: none;
			   -moz-user-select: none;
			        user-select: none;
		}
	}
</style>
