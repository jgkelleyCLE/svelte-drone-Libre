import { existsSync, readFileSync } from 'node:fs';
import { extname, join } from 'node:path';
import { cwd } from 'node:process';
import { getStackByName } from '../../actions/blueprints/stacks.js';
import { BlueprintErrorType } from '../../utils/types.js';
// @ts-ignore - this is currently untyped
import blueprintParserValidator from '../../utils/vendor/parser-validator.js';
const SUPPORTED_FILE_NAMES_IN_PRIORITY_ORDER = [
    'blueprint.json',
    // 'blueprint.js',
    // 'blueprint.mjs',
    // 'blueprint.cjs',
    // 'blueprint.ts',
];
function findBlueprintFile(blueprintPath) {
    if (blueprintPath) {
        if (existsSync(blueprintPath)) {
            return { path: blueprintPath, fileName: blueprintPath, extension: extname(blueprintPath) };
        }
        throw Error(`Blueprint file not found: ${blueprintPath}`);
    }
    for (const fileName of SUPPORTED_FILE_NAMES_IN_PRIORITY_ORDER) {
        const filePath = join(cwd(), fileName);
        if (existsSync(filePath)) {
            return { path: filePath, fileName, extension: extname(filePath) };
        }
    }
    return null;
}
export default async function readBlueprintOnDisk({ blueprintPath, getStack, } = {}) {
    try {
        const blueprintFile = findBlueprintFile(blueprintPath);
        if (!blueprintFile)
            throw Error('Could not find Blueprint file');
        const { path, fileName, extension } = blueprintFile;
        let blueprintString;
        if (extension === '.json') {
            blueprintString = readFileSync(path, 'utf8').toString();
            // } else if (extension === '.js' || extension === '.mjs') {
            //   const blueprintModule = require(path)
            //   blueprintJson = blueprintModule.default
        }
        else {
            throw Error(`Unsupported blueprint file extension: ${extension}`);
        }
        const parsed = blueprintParserValidator(JSON.parse(blueprintString));
        const { blueprint: parsedBlueprint } = parsed;
        const errors = parsed.errors || [];
        const projectResource = parsedBlueprint.resources.find((r) => r.type === 'sanity.project');
        const stackResource = parsedBlueprint.resources.find((r) => r.type === 'sanity.blueprints.stack');
        if (!projectResource) {
            errors.push({
                message: 'Blueprint is missing a project resource',
                type: BlueprintErrorType.MissingProject,
            });
        }
        if (!stackResource) {
            errors.push({
                message: 'Blueprint is missing a stack resource',
                type: BlueprintErrorType.MissingStack,
            });
        }
        let deployedStack;
        if (getStack && projectResource && stackResource) {
            const { stack } = await getStackByName({
                name: stackResource.name,
                projectId: projectResource.id,
            });
            if (!stack) {
                errors.push({
                    message: 'Stack not found',
                    type: BlueprintErrorType.InvalidStack,
                });
            }
            deployedStack = stack;
        }
        return {
            fileInfo: { path, fileName, extension },
            errors,
            projectResource,
            stackResource,
            deployedStack,
            parsedBlueprint,
        };
    }
    catch (err) {
        throw Error(`Unable to parse Blueprint file: ${err}`);
    }
}
