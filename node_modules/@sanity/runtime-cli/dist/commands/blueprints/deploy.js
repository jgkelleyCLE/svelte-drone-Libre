import { Command } from '@oclif/core';
import readBlueprintOnDisk from '../../actions/blueprints/read-blueprint.js';
import { createStack, updateStack } from '../../actions/blueprints/stacks.js';
import { stashAsset } from '../../actions/blueprints/stash-asset.js';
import { green, red, yellow } from '../../utils/display/colors.js';
import Spinner from '../../utils/spinner.js';
export default class Deploy extends Command {
    static description = 'Deploy a Blueprint';
    static examples = ['<%= config.bin %> <%= command.id %>'];
    async run() {
        const { errors, projectResource, stackResource, parsedBlueprint: { resources }, deployedStack, } = await readBlueprintOnDisk({ getStack: true });
        if (errors.length > 0) {
            // printErrors(errors) // TODO: error printer in formatting
            this.log('Blueprint parse errors:');
            console.dir(errors, { depth: null });
            return;
        }
        if (!projectResource)
            this.error('Blueprint must contain a project resource'); // returns
        if (!stackResource)
            this.error('Blueprint must contain a stack resource'); // returns
        const { id: projectId } = projectResource;
        const { name } = stackResource;
        const s = new Spinner();
        const functionResources = resources.filter((r) => r.type === 'function');
        // First stash all function assets
        if (functionResources.length > 0) {
            for (const resource of functionResources) {
                const fnSpinner = new Spinner();
                fnSpinner.start(`Processing ${resource.name}...`);
                const result = await stashAsset({ resource, projectId });
                if (result.success) {
                    const src = resource.src;
                    resource.src = result.assetId; // TODO: properly reference asset - for now, the API expects the assetId
                    fnSpinner.stop(`${green('✓')} ${resource.name} <${yellow(result.assetId)}>`);
                    this.log(`   Source: ${src}`);
                }
                else {
                    fnSpinner.stop(`${red('✗')} Failed to process ${resource.name}`);
                    this.log(`   Error: ${result.error}`);
                    return;
                }
            }
        }
        const blueprint = {
            name,
            projectId,
            document: { resources },
        };
        this.debug('BLUEPRINT DOCUMENT:', blueprint);
        const { ok: deployOk, stack, error: deployError, } = deployedStack
            ? await updateStack({ stackId: deployedStack.id, blueprint, projectId })
            : await createStack({ blueprint, projectId });
        this.debug('STACK RESPONSE:', stack);
        if (deployOk) {
            s.stop(`${green('Success!')} Stack ${deployedStack ? 'updated' : 'created'} <${yellow(stack.id)}>`);
            this.log('\nUse `sanity blueprints info` to check deployment status');
        }
        else {
            this.debug('STACK ERROR RESPONSE:', stack);
            s.stop(`${red('Failed')} to ${deployedStack ? 'update' : 'create'} stack`);
            this.log(`Error: ${deployError || 'Unknown error'}`);
        }
    }
}
