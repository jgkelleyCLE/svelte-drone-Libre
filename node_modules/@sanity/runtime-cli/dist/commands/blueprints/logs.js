import { Command, Flags } from '@oclif/core';
import { getLogs, streamLogs } from '../../actions/blueprints/logs.js';
import readBlueprintOnDisk from '../../actions/blueprints/read-blueprint.js';
import config from '../../config.js';
import { formatTitle } from '../../utils/display/blueprints-formatting.js';
import { blue, bold, green, red, yellow } from '../../utils/display/colors.js';
import Spinner from '../../utils/spinner.js';
export default class Logs extends Command {
    static description = 'Display logs for a Blueprint stack';
    static examples = [
        '<%= config.bin %> <%= command.id %>',
        '<%= config.bin %> <%= command.id %> --watch',
    ];
    static flags = {
        watch: Flags.boolean({
            char: 'w',
            description: 'Watch for new logs (streaming mode)',
            required: false,
            default: false,
        }),
    };
    async run() {
        const { flags } = await this.parse(Logs);
        const watchMode = flags.watch;
        const s = new Spinner();
        try {
            const { errors, deployedStack } = await readBlueprintOnDisk({ getStack: true });
            if (errors.length > 0) {
                // printErrors(errors)
                this.log('Blueprint parse errors:');
                console.dir(errors, { depth: null });
                return;
            }
            if (!deployedStack)
                this.error('Stack not found'); // returns
            const { id: stackId, projectId, name } = deployedStack;
            if (watchMode) {
                // recent logs
                s.start(`Fetching recent logs for stack ${stackId}`);
                const { ok, logs, error } = await getLogs(stackId, projectId, config.token);
                if (!ok) {
                    s.stop(`${red('Failed')} to retrieve logs`);
                    this.log(`Error: ${error || 'Unknown error'}`);
                    return;
                }
                s.stop(`${formatTitle('Blueprint', name)} ${bold('Live')} Logs`);
                if (logs.length > 0) {
                    this.log('\nMost recent logs:');
                    const sortedLogs = [...logs].sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                    const recentLogs = sortedLogs.slice(-10);
                    for (const log of recentLogs) {
                        const date = new Date(log.timestamp);
                        const time = date.toLocaleTimeString();
                        const day = date.toLocaleDateString();
                        this.log(`  ${bold(day)} ${yellow(time)} ${log.message}`);
                    }
                }
                else {
                    this.log(`No recent logs found for stack ${yellow(stackId)}`);
                }
                const onOpen = () => {
                    this.log(`\n${bold('Watching')} for new logs...`);
                    this.log(`Press ${bold('Ctrl+C')} to stop\n`);
                };
                let newestTimestamp = 0;
                if (logs.length > 0) {
                    for (const log of logs) {
                        const timestamp = new Date(log.timestamp).getTime();
                        if (timestamp > newestTimestamp) {
                            newestTimestamp = timestamp;
                        }
                    }
                }
                const renderLog = (log) => {
                    const logTimestamp = new Date(log.timestamp).getTime();
                    if (logTimestamp <= newestTimestamp) {
                        return;
                    }
                    newestTimestamp = logTimestamp;
                    const date = new Date(log.timestamp);
                    const time = date.toLocaleTimeString();
                    const day = date.toLocaleDateString();
                    this.log(`${green('>')} ${bold(day)} ${yellow(time)} ${log.message}`);
                };
                this.debug(`${yellow('Debug:')} Connecting to streaming endpoint for stack ${stackId}...`);
                streamLogs(stackId, projectId, config.token, renderLog, onOpen, (error) => this.log(`${red('Error:')} ${error}`));
                return new Promise(() => {
                    // hold the line until the user terminates with Ctrl+C
                });
            }
            s.start(`Fetching logs for stack ${stackId}`);
            const { ok, logs, error } = await getLogs(stackId, projectId, config.token);
            if (!ok) {
                s.stop(`${red('Failed')} to retrieve logs`);
                this.log(`Error: ${error || 'Unknown error'}`);
                return;
            }
            if (logs.length === 0) {
                s.stop(`No logs found for stack ${stackId}`);
                return;
            }
            s.stop(`${formatTitle('Blueprint', name)} Logs`);
            this.log(`Found ${bold(logs.length.toString())} log entries for stack ${yellow(stackId)}\n`);
            const logsByDay = new Map();
            for (const log of logs) {
                const date = new Date(log.timestamp);
                const day = date.toLocaleDateString();
                if (!logsByDay.has(day)) {
                    logsByDay.set(day, []);
                }
                logsByDay.get(day)?.push(log);
            }
            const sortedDays = Array.from(logsByDay.keys()).sort((a, b) => {
                return new Date(a).getTime() - new Date(b).getTime();
            });
            for (const day of sortedDays) {
                this.log(`${blue('Date:')} ${bold(day)}`);
                const dayLogs = logsByDay.get(day) || [];
                dayLogs.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                for (const [i, log] of dayLogs.entries()) {
                    const date = new Date(log.timestamp);
                    const time = date.toLocaleTimeString();
                    const isLast = i === dayLogs.length - 1;
                    this.log(`  ${isLast ? '└─' : '├─'} ${yellow(time)} ${log.message}`);
                }
                // new line between days
                this.log('');
            }
        }
        catch (err) {
            s.stop('Failed to retrieve logs');
            if (err instanceof Error) {
                this.log(`Error: ${err.message}`);
            }
        }
    }
}
