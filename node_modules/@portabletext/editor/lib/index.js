import { toPortableTextRange, EditorActorContext, getEditorSnapshot, debugWithName, fromSlateValue, KEY_TO_VALUE_ELEMENT, usePortableTextEditor, PortableTextEditor, toSlateRange, moveRangeByOperation, isEqualToEmptyEditor, useEditor } from "./_chunks-es/editor-provider.js";
import { EditorProvider, defineSchema, defaultKeyGenerator, useEditorSelector, usePortableTextEditorSelection } from "./_chunks-es/editor-provider.js";
import { jsxs, jsx, Fragment } from "react/jsx-runtime";
import { useSelector } from "@xstate/react";
import isEqual from "lodash/isEqual.js";
import noop from "lodash/noop.js";
import { useContext, useState, useEffect, useRef, useMemo, startTransition, useCallback, forwardRef, useImperativeHandle } from "react";
import { Editor, Range, Element as Element$1, Text, Transforms, Path } from "slate";
import { ReactEditor, useSlateStatic, useSelected, useSlate, Editable } from "slate-react";
import { DOMEditor, isDOMNode } from "slate-dom";
import { getBlockStartPoint, getBlockEndPoint } from "./_chunks-es/util.slice-blocks.js";
import { isSelectionCollapsed, getFocusTextBlock, getFocusSpan, getFocusBlock, getSelectedBlocks } from "./_chunks-es/selector.is-at-the-start-of-block.js";
import { parseBlocks } from "./_chunks-es/parse-blocks.js";
import { isSelectingEntireBlocks } from "./_chunks-es/selector.is-overlapping-selection.js";
import { defineBehavior, isHotkey } from "./_chunks-es/behavior.core.js";
import { c } from "react-compiler-runtime";
import uniq from "lodash/uniq.js";
import { useEffectEvent } from "use-effect-event";
function getEventPosition({
  snapshot,
  slateEditor,
  event
}) {
  if (!DOMEditor.hasTarget(slateEditor, event.target))
    return;
  const node = DOMEditor.toSlateNode(slateEditor, event.target);
  if (isClipboardEvent(event)) {
    const selection2 = snapshot.context.selection;
    return selection2 ? {
      block: "end",
      isEditor: Editor.isEditor(node),
      selection: selection2
    } : void 0;
  }
  const block = getEventPositionBlock({
    slateEditor,
    event
  }), selection = getEventPositionSelection({
    snapshot,
    slateEditor,
    event
  });
  if (!(!block || !selection))
    return {
      block,
      isEditor: Editor.isEditor(node),
      selection
    };
}
function getEventPositionBlock({
  slateEditor,
  event
}) {
  if (!ReactEditor.hasTarget(slateEditor, event.target))
    return;
  const node = ReactEditor.toSlateNode(slateEditor, event.target), elementRect = ReactEditor.toDOMNode(slateEditor, node).getBoundingClientRect(), top = elementRect.top, height = elementRect.height;
  return Math.abs(top - event.pageY) < height / 2 ? "start" : "end";
}
function getEventPositionSelection({
  snapshot,
  slateEditor,
  event
}) {
  const range = getSlateRangeFromEvent(slateEditor, event), selection = range ? toPortableTextRange(snapshot.context.value, range, snapshot.context.schema) : null;
  if (!selection)
    return selection;
  const collapsedSelection = isSelectionCollapsed({
    context: {
      ...snapshot.context,
      selection
    }
  }), focusTextBlock = getFocusTextBlock({
    context: {
      ...snapshot.context,
      selection
    }
  }), focusSpan = getFocusSpan({
    context: {
      ...snapshot.context,
      selection
    }
  });
  if (event.type === "dragstart" && collapsedSelection && focusTextBlock && focusSpan) {
    const blockStartPoint = getBlockStartPoint(focusTextBlock), blockEndPoint = getBlockEndPoint(focusTextBlock);
    return {
      anchor: blockStartPoint,
      focus: blockEndPoint
    };
  }
  return selection;
}
function getSlateRangeFromEvent(editor, event) {
  if (!event.target || !isDOMNode(event.target))
    return;
  const window2 = DOMEditor.getWindow(editor);
  let domRange;
  if (window2.document.caretPositionFromPoint !== void 0) {
    const position = window2.document.caretPositionFromPoint(event.clientX, event.clientY);
    position && (domRange = window2.document.createRange(), domRange.setStart(position.offsetNode, position.offset), domRange.setEnd(position.offsetNode, position.offset));
  } else if (window2.document.caretRangeFromPoint !== void 0)
    domRange = window2.document.caretRangeFromPoint(event.clientX, event.clientY) ?? void 0;
  else {
    console.warn("Neither caretPositionFromPoint nor caretRangeFromPoint is supported");
    return;
  }
  if (!domRange)
    return;
  let range;
  try {
    range = DOMEditor.toSlateRange(editor, domRange, {
      exactMatch: !1,
      // It can still throw even with this option set to true
      suppressThrow: !1
    });
  } catch {
  }
  return range;
}
function isClipboardEvent(event) {
  return event.type === "copy" || event.type === "cut" || event.type === "paste";
}
function normalizePoint(point, value) {
  if (!point || !value)
    return null;
  const newPath = [];
  let newOffset = point.offset || 0;
  const blockKey = typeof point.path[0] == "object" && "_key" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == "object" && "_key" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);
  if (block)
    newPath.push({
      _key: block._key
    });
  else
    return null;
  if (block && point.path[1] === "children") {
    if (!block.children || Array.isArray(block.children) && block.children.length === 0)
      return null;
    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);
    if (child)
      newPath.push("children"), newPath.push({
        _key: child._key
      }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;
    else
      return null;
  }
  return {
    path: newPath,
    offset: newOffset
  };
}
function normalizeSelection(selection, value) {
  if (!selection || !value || value.length === 0)
    return null;
  let newAnchor = null, newFocus = null;
  const {
    anchor,
    focus
  } = selection;
  return anchor && value.find((blk) => isEqual({
    _key: blk._key
  }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => isEqual({
    _key: blk._key
  }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {
    anchor: newAnchor,
    focus: newFocus,
    backward: selection.backward
  } : null;
}
function DefaultBlockObject(props) {
  const $ = c(4);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    userSelect: "none"
  }, $[0] = t0) : t0 = $[0];
  let t1;
  return $[1] !== props.value._key || $[2] !== props.value._type ? (t1 = /* @__PURE__ */ jsxs("div", { style: t0, children: [
    "[",
    props.value._type,
    ": ",
    props.value._key,
    "]"
  ] }), $[1] = props.value._key, $[2] = props.value._type, $[3] = t1) : t1 = $[3], t1;
}
function DefaultInlineObject(props) {
  const $ = c(4);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    userSelect: "none"
  }, $[0] = t0) : t0 = $[0];
  let t1;
  return $[1] !== props.value._key || $[2] !== props.value._type ? (t1 = /* @__PURE__ */ jsxs("span", { style: t0, children: [
    "[",
    props.value._type,
    ": ",
    props.value._key,
    "]"
  ] }), $[1] = props.value._key, $[2] = props.value._type, $[3] = t1) : t1 = $[3], t1;
}
function DropIndicator() {
  const $ = c(1);
  let t0;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ jsx("div", { className: "pt-drop-indicator", style: {
    position: "absolute",
    width: "100%",
    height: 1,
    borderBottom: "1px solid currentColor",
    zIndex: 5
  } }), $[0] = t0) : t0 = $[0], t0;
}
function useDraggable(props) {
  const $ = c(15), editorActor = useContext(EditorActorContext), editor = useSlateStatic(), [blockElement, setBlockElement] = useState(null);
  let t0, t1;
  $[0] !== editor || $[1] !== props.blockRef || $[2] !== props.element ? (t0 = () => setBlockElement(props.blockRef ? props.blockRef.current : ReactEditor.toDOMNode(editor, props.element)), t1 = [editor, props.element, props.blockRef], $[0] = editor, $[1] = props.blockRef, $[2] = props.element, $[3] = t0, $[4] = t1) : (t0 = $[3], t1 = $[4]), useEffect(t0, t1);
  let t2;
  $[5] !== editorActor ? (t2 = () => {
    editorActor.send({
      type: "dragend"
    });
  }, $[5] = editorActor, $[6] = t2) : t2 = $[6];
  const handleDragEnd = t2;
  let t3;
  $[7] !== blockElement || $[8] !== editor || $[9] !== editorActor ? (t3 = (event) => {
    const position = getEventPosition({
      snapshot: getEditorSnapshot({
        editorActorSnapshot: editorActor.getSnapshot(),
        slateEditorInstance: editor
      }),
      slateEditor: editor,
      event: event.nativeEvent
    });
    if (!position) {
      console.error("Could not find position for dragstart event");
      return;
    }
    if (blockElement && blockElement instanceof HTMLElement) {
      let dragGhost = blockElement.cloneNode(!0);
      const customGhost = dragGhost.querySelector("[data-pt-drag-ghost-element]");
      if (customGhost && (dragGhost = customGhost), dragGhost.setAttribute("data-dragged", ""), document.body) {
        dragGhost.style.position = "absolute", dragGhost.style.left = "-99999px", dragGhost.style.boxSizing = "border-box", document.body.appendChild(dragGhost);
        const rect = blockElement.getBoundingClientRect(), x = event.clientX - rect.left, y = event.clientY - rect.top;
        dragGhost.style.width = `${rect.width}px`, dragGhost.style.height = `${rect.height}px`, event.dataTransfer.setDragImage(dragGhost, x, y), editorActor.send({
          type: "dragstart",
          origin: position,
          ghost: dragGhost
        });
        return;
      }
      editorActor.send({
        type: "dragstart",
        origin: position
      });
    }
  }, $[7] = blockElement, $[8] = editor, $[9] = editorActor, $[10] = t3) : t3 = $[10];
  const handleDragStart = t3;
  if (props.readOnly) {
    let t42;
    return $[11] === Symbol.for("react.memo_cache_sentinel") ? (t42 = {
      draggableProps: {
        draggable: !1,
        onDragStart: void 0,
        onDragEnd: void 0
      }
    }, $[11] = t42) : t42 = $[11], t42;
  }
  let t4;
  return $[12] !== handleDragEnd || $[13] !== handleDragStart ? (t4 = {
    draggableProps: {
      draggable: !0,
      onDragStart: handleDragStart,
      onDragEnd: handleDragEnd
    }
  }, $[12] = handleDragEnd, $[13] = handleDragStart, $[14] = t4) : t4 = $[14], t4;
}
debugWithName("components:Element");
const EMPTY_ANNOTATIONS = [], inlineBlockStyle = {
  display: "inline-block"
}, Element = ({
  attributes,
  children,
  element,
  schemaTypes,
  readOnly,
  renderBlock,
  renderChild,
  renderListItem,
  renderStyle,
  spellCheck
}) => {
  const editorActor = useContext(EditorActorContext), slateEditor = useSlateStatic(), selected = useSelected(), blockRef = useRef(null), inlineBlockObjectRef = useRef(null), focused = selected && slateEditor.selection && Range.isCollapsed(slateEditor.selection) || !1, [dragPositionBlock, setDragPositionBlock] = useState(), draggable = useDraggable({
    element,
    readOnly,
    blockRef
  });
  useEffect(() => {
    const behavior = defineBehavior({
      on: "drag.dragover",
      guard: ({
        snapshot,
        event
      }) => {
        const dropFocusBlock = getFocusBlock({
          context: {
            ...snapshot.context,
            selection: event.position.selection
          }
        });
        if (!dropFocusBlock || dropFocusBlock.node._key !== element._key)
          return !1;
        const dragOrigin = snapshot.beta.internalDrag?.origin;
        return !dragOrigin || getSelectedBlocks({
          context: {
            ...snapshot.context,
            selection: dragOrigin.selection
          }
        }).some((draggedBlock) => draggedBlock.node._key === element._key) ? !1 : isSelectingEntireBlocks({
          context: {
            ...snapshot.context,
            selection: dragOrigin.selection
          }
        });
      },
      actions: [({
        event: event_0
      }) => [{
        type: "effect",
        effect: () => {
          setDragPositionBlock(event_0.position.block);
        }
      }, {
        type: "noop"
      }]]
    });
    return editorActor.send({
      type: "add behavior",
      behavior
    }), () => {
      editorActor.send({
        type: "remove behavior",
        behavior
      });
    };
  }, [editorActor, element._key]), useEffect(() => {
    const behavior_0 = defineBehavior({
      on: "drag.*",
      guard: ({
        event: event_1
      }) => event_1.type !== "drag.dragover",
      actions: [() => [{
        type: "effect",
        effect: () => {
          setDragPositionBlock(void 0);
        }
      }]]
    });
    return editorActor.send({
      type: "add behavior",
      behavior: behavior_0
    }), () => {
      editorActor.send({
        type: "remove behavior",
        behavior: behavior_0
      });
    };
  }, [editorActor]);
  const value = useMemo(() => fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(slateEditor))[0], [slateEditor, element, schemaTypes.block.name]);
  let renderedBlock = children, className;
  const blockPath = useMemo(() => [{
    _key: element._key
  }], [element]);
  if (typeof element._type != "string")
    throw new Error("Expected element to have a _type property");
  if (typeof element._key != "string")
    throw new Error("Expected element to have a _key property");
  if (slateEditor.isInline(element)) {
    const path = ReactEditor.findPath(slateEditor, element), [block] = Editor.node(slateEditor, path, {
      depth: 1
    }), schemaType = schemaTypes.inlineObjects.find((_type) => _type.name === element._type);
    if (!schemaType)
      throw new Error("Could not find type for inline block element");
    if (Element$1.isElement(block)) {
      const elmPath = [{
        _key: block._key
      }, "children", {
        _key: element._key
      }];
      return /* @__PURE__ */ jsxs("span", { ...attributes, children: [
        children,
        /* @__PURE__ */ jsxs("span", { draggable: !readOnly, className: "pt-inline-object", "data-testid": "pt-inline-object", ref: inlineBlockObjectRef, style: inlineBlockStyle, contentEditable: !1, children: [
          renderChild && renderChild({
            annotations: EMPTY_ANNOTATIONS,
            // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.
            children: /* @__PURE__ */ jsx(DefaultInlineObject, { value }),
            editorElementRef: inlineBlockObjectRef,
            focused,
            path: elmPath,
            schemaType,
            selected,
            type: schemaType,
            value
          }),
          !renderChild && /* @__PURE__ */ jsx(DefaultInlineObject, { value })
        ] }, element._key)
      ] });
    }
    throw new Error("Block not found!");
  }
  if (element._type === schemaTypes.block.name) {
    className = "pt-block pt-text-block";
    const isListItem = "listItem" in element, style = "style" in element && element.style || "normal";
    className = `pt-block pt-text-block pt-text-block-style-${style}`;
    const blockStyleType = schemaTypes.styles.find((item) => item.value === style);
    renderStyle && blockStyleType && (renderedBlock = renderStyle({
      block: element,
      children,
      focused,
      selected,
      value: style,
      path: blockPath,
      schemaType: blockStyleType,
      editorElementRef: blockRef
    }));
    let level;
    if (isListItem && (typeof element.level == "number" && (level = element.level), className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`), slateEditor.isListBlock(value) && isListItem && element.listItem) {
      const listType = schemaTypes.lists.find((item_0) => item_0.value === element.listItem);
      renderListItem && listType && (renderedBlock = renderListItem({
        block: value,
        children: renderedBlock,
        focused,
        selected,
        value: element.listItem,
        path: blockPath,
        schemaType: listType,
        level: value.level || 1,
        editorElementRef: blockRef
      }));
    }
    const renderProps = Object.defineProperty({
      children: renderedBlock,
      editorElementRef: blockRef,
      focused,
      level,
      listItem: isListItem ? element.listItem : void 0,
      path: blockPath,
      selected,
      style,
      schemaType: schemaTypes.block,
      value
    }, "type", {
      enumerable: !1,
      get() {
        return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaTypes.block;
      }
    }), propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;
    return /* @__PURE__ */ jsxs("div", { ...attributes, className, spellCheck, children: [
      dragPositionBlock === "start" ? /* @__PURE__ */ jsx(DropIndicator, {}) : null,
      /* @__PURE__ */ jsx("div", { ref: blockRef, children: propsOrDefaultRendered }),
      dragPositionBlock === "end" ? /* @__PURE__ */ jsx(DropIndicator, {}) : null
    ] }, element._key);
  }
  const schemaType_0 = schemaTypes.blockObjects.find((_type_0) => _type_0.name === element._type);
  if (!schemaType_0)
    throw new Error(`Could not find schema type for block element of _type ${element._type}`);
  className = "pt-block pt-object-block";
  const block_0 = fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(slateEditor))[0];
  let renderedBlockFromProps;
  if (renderBlock) {
    const _props = Object.defineProperty({
      children: /* @__PURE__ */ jsx(DefaultBlockObject, { value }),
      editorElementRef: blockRef,
      focused,
      path: blockPath,
      schemaType: schemaType_0,
      selected,
      value: block_0
    }, "type", {
      enumerable: !1,
      get() {
        return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaType_0;
      }
    });
    renderedBlockFromProps = renderBlock(_props);
  }
  return /* @__PURE__ */ jsxs("div", { ...attributes, className, ...draggable.draggableProps, children: [
    dragPositionBlock === "start" ? /* @__PURE__ */ jsx(DropIndicator, {}) : null,
    children,
    /* @__PURE__ */ jsx("div", { ref: blockRef, contentEditable: !1, children: renderedBlockFromProps || /* @__PURE__ */ jsx(DefaultBlockObject, { value }) }),
    dragPositionBlock === "end" ? /* @__PURE__ */ jsx(DropIndicator, {}) : null
  ] }, element._key);
};
Element.displayName = "Element";
const debug$2 = debugWithName("components:Leaf"), EMPTY_MARKS = [], Leaf = (props) => {
  const {
    editorActor,
    attributes,
    children,
    leaf,
    schemaTypes,
    renderChild,
    renderDecorator,
    renderAnnotation
  } = props, spanRef = useRef(null), portableTextEditor = usePortableTextEditor(), blockSelected = useSelected(), [focused, setFocused] = useState(!1), [selected, setSelected] = useState(!1), block = children.props.parent, path = useMemo(() => block ? [{
    _key: block?._key
  }, "children", {
    _key: leaf._key
  }] : [], [block, leaf._key]), decoratorValues = useMemo(() => schemaTypes.decorators.map((dec) => dec.value), [schemaTypes.decorators]), marks = useMemo(() => uniq((leaf.marks || EMPTY_MARKS).filter((mark) => decoratorValues.includes(mark))), [decoratorValues, leaf.marks]), annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS, annotations = useMemo(() => annotationMarks.map((mark_0) => !decoratorValues.includes(mark_0) && block?.markDefs?.find((def) => def._key === mark_0)).filter(Boolean), [annotationMarks, block, decoratorValues]), shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;
  useEffect(() => {
    if (!shouldTrackSelectionAndFocus) {
      setFocused(!1);
      return;
    }
    const sel = PortableTextEditor.getSelection(portableTextEditor);
    sel && isEqual(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && startTransition(() => {
      setFocused(!0);
    });
  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);
  const setSelectedFromRange = useCallback(() => {
    if (!shouldTrackSelectionAndFocus)
      return;
    debug$2("Setting selection and focus from range");
    const winSelection = window.getSelection();
    if (!winSelection) {
      setSelected(!1);
      return;
    }
    if (winSelection && winSelection.rangeCount > 0) {
      const range = winSelection.getRangeAt(0);
      spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);
    } else
      setSelected(!1);
  }, [shouldTrackSelectionAndFocus]);
  useEffect(() => {
    if (!shouldTrackSelectionAndFocus)
      return;
    const onBlur = editorActor.on("blur", () => {
      setFocused(!1), setSelected(!1);
    }), onFocus = editorActor.on("focus", () => {
      const sel_0 = PortableTextEditor.getSelection(portableTextEditor);
      sel_0 && isEqual(sel_0.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();
    }), onSelection = editorActor.on("selection", (event) => {
      event.selection && isEqual(event.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange();
    });
    return () => {
      onBlur.unsubscribe(), onFocus.unsubscribe(), onSelection.unsubscribe();
    };
  }, [editorActor, path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]), useEffect(() => setSelectedFromRange(), [setSelectedFromRange]);
  const content = useMemo(() => {
    let returnedChildren = children;
    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name && (marks.forEach((mark_1) => {
      const schemaType = schemaTypes.decorators.find((dec_0) => dec_0.value === mark_1);
      if (schemaType && renderDecorator) {
        const _props = Object.defineProperty({
          children: returnedChildren,
          editorElementRef: spanRef,
          focused,
          path,
          selected,
          schemaType,
          value: mark_1
        }, "type", {
          enumerable: !1,
          get() {
            return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaType;
          }
        });
        returnedChildren = renderDecorator(_props);
      }
    }), block && annotations.length > 0 && annotations.forEach((annotation) => {
      const schemaType_0 = schemaTypes.annotations.find((t) => t.name === annotation._type);
      if (schemaType_0)
        if (renderAnnotation) {
          const _props_0 = Object.defineProperty({
            block,
            children: returnedChildren,
            editorElementRef: spanRef,
            focused,
            path,
            selected,
            schemaType: schemaType_0,
            value: annotation
          }, "type", {
            enumerable: !1,
            get() {
              return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaType_0;
            }
          });
          returnedChildren = /* @__PURE__ */ jsx("span", { ref: spanRef, children: renderAnnotation(_props_0) });
        } else
          returnedChildren = /* @__PURE__ */ jsx("span", { ref: spanRef, children: returnedChildren });
    }), block && renderChild)) {
      const child = block.children.find((_child) => _child._key === leaf._key);
      if (child) {
        const _props_1 = Object.defineProperty({
          annotations,
          children: /* @__PURE__ */ jsx(Fragment, { children: returnedChildren }),
          editorElementRef: spanRef,
          focused,
          path,
          schemaType: schemaTypes.span,
          selected,
          value: child
        }, "type", {
          enumerable: !1,
          get() {
            return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaTypes.span;
          }
        });
        returnedChildren = renderChild(_props_1);
      }
    }
    return returnedChildren;
  }, [annotations, block, children, focused, leaf, marks, path, renderAnnotation, renderChild, renderDecorator, schemaTypes.annotations, schemaTypes.decorators, schemaTypes.span, selected]);
  return useMemo(() => /* @__PURE__ */ jsx("span", { ...attributes, ref: spanRef, children: content }, leaf._key), [leaf, attributes, content]);
};
Leaf.displayName = "Leaf";
const debug$1 = debugWithName("plugin:withHotKeys");
function createWithHotkeys(editorActor, portableTextEditor, hotkeysFromOptions) {
  const reservedHotkeys = ["enter", "tab", "shift", "delete", "end"], activeHotkeys = hotkeysFromOptions ?? {};
  return function(editor) {
    return editor.pteWithHotKeys = (event) => {
      Object.keys(activeHotkeys).forEach((cat) => {
        if (cat === "marks")
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey))
              throw new Error(`The hotkey ${hotkey} is reserved!`);
            if (isHotkey(hotkey, event.nativeEvent)) {
              event.preventDefault();
              const possibleMark = activeHotkeys[cat];
              if (possibleMark) {
                const mark = possibleMark[hotkey];
                debug$1(`HotKey ${hotkey} to toggle ${mark}`), editorActor.send({
                  type: "behavior event",
                  behaviorEvent: {
                    type: "decorator.toggle",
                    decorator: mark
                  },
                  editor
                });
              }
            }
          }
        if (cat === "custom")
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey))
              throw new Error(`The hotkey ${hotkey} is reserved!`);
            if (isHotkey(hotkey, event.nativeEvent)) {
              const possibleCommand = activeHotkeys[cat];
              if (possibleCommand) {
                const command = possibleCommand[hotkey];
                command(event, portableTextEditor);
              }
            }
          }
      });
    }, editor;
  };
}
function withSyncRangeDecorations({
  editorActor,
  slateEditor,
  syncRangeDecorations
}) {
  const originalApply = slateEditor.apply;
  return slateEditor.apply = (op) => {
    originalApply(op), !editorActor.getSnapshot().matches({
      "edit mode": "read only"
    }) && op.type !== "set_selection" && syncRangeDecorations(op);
  }, () => {
    slateEditor.apply = originalApply;
  };
}
const debug = debugWithName("component:Editable"), PLACEHOLDER_STYLE = {
  position: "absolute",
  userSelect: "none",
  pointerEvents: "none",
  left: 0,
  right: 0
}, PortableTextEditable = forwardRef(function(props, forwardedRef) {
  const {
    hotkeys,
    onBlur,
    onFocus,
    onBeforeInput,
    onPaste,
    onCopy,
    onCut,
    onClick,
    onDragStart,
    onDrag,
    onDragEnd,
    onDragEnter,
    onDragOver,
    onDrop,
    onDragLeave,
    rangeDecorations,
    renderAnnotation,
    renderBlock,
    renderChild,
    renderDecorator,
    renderListItem,
    renderPlaceholder,
    renderStyle,
    selection: propsSelection,
    scrollSelectionIntoView,
    spellCheck,
    ...restProps
  } = props, portableTextEditor = usePortableTextEditor(), ref = useRef(null), [editableElement, setEditableElement] = useState(null), [hasInvalidValue, setHasInvalidValue] = useState(!1), [rangeDecorationState, setRangeDecorationsState] = useState([]);
  useImperativeHandle(forwardedRef, () => ref.current);
  const rangeDecorationsRef = useRef(rangeDecorations), editorActor = useContext(EditorActorContext), readOnly = useSelector(editorActor, (s) => s.matches({
    "edit mode": "read only"
  })), schemaTypes = useSelector(editorActor, (s_0) => s_0.context.schema), slateEditor = useSlate(), blockTypeName = schemaTypes.block.name;
  useMemo(() => {
    if (readOnly)
      return debug("Editable is in read only mode"), slateEditor;
    const withHotKeys = createWithHotkeys(editorActor, portableTextEditor, hotkeys);
    return debug("Editable is in edit mode"), withHotKeys(slateEditor);
  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor]);
  const renderElement = useCallback((eProps) => /* @__PURE__ */ jsx(Element, { ...eProps, readOnly, renderBlock, renderChild, renderListItem, renderStyle, schemaTypes, spellCheck }), [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]), renderLeaf = useCallback((lProps) => {
    if (lProps.leaf._type === "span") {
      let rendered = /* @__PURE__ */ jsx(Leaf, { ...lProps, editorActor, schemaTypes, renderAnnotation, renderChild, renderDecorator, readOnly });
      if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === "")
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx("span", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: renderPlaceholder() }),
          rendered
        ] });
      const decoration = lProps.leaf.rangeDecoration;
      return decoration && (rendered = decoration.component({
        children: rendered
      })), rendered;
    }
    return lProps.children;
  }, [editorActor, readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder, schemaTypes]), restoreSelectionFromProps = useCallback(() => {
    if (propsSelection) {
      debug(`Selection from props ${JSON.stringify(propsSelection)}`);
      const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, blockTypeName));
      if (normalizedSelection !== null) {
        debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);
        const slateRange = toSlateRange(normalizedSelection, slateEditor);
        slateRange && (Transforms.select(slateEditor, slateRange), slateEditor.operations.some((o) => o.type === "set_selection") || editorActor.send({
          type: "notify.selection",
          selection: normalizedSelection
        }), slateEditor.onChange());
      }
    }
  }, [blockTypeName, editorActor, propsSelection, slateEditor]), syncRangeDecorations = useCallback((operation) => {
    if (rangeDecorations && rangeDecorations.length > 0) {
      const newSlateRanges = [];
      if (rangeDecorations.forEach((rangeDecorationItem) => {
        const slateRange_0 = toSlateRange(rangeDecorationItem.selection, slateEditor);
        if (!Range.isRange(slateRange_0)) {
          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({
            newSelection: null,
            rangeDecoration: rangeDecorationItem,
            origin: "local"
          });
          return;
        }
        let newRange;
        if (operation && (newRange = moveRangeByOperation(slateRange_0, operation), newRange && newRange !== slateRange_0 || newRange === null && slateRange_0)) {
          const value = PortableTextEditor.getValue(portableTextEditor), newRangeSelection = toPortableTextRange(value, newRange, schemaTypes);
          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({
            newSelection: newRangeSelection,
            rangeDecoration: rangeDecorationItem,
            origin: "local"
          });
        }
        newRange !== null && newSlateRanges.push({
          ...newRange || slateRange_0,
          rangeDecoration: rangeDecorationItem
        });
      }), newSlateRanges.length > 0) {
        setRangeDecorationsState(newSlateRanges);
        return;
      }
    }
    setRangeDecorationsState((rangeDecorationState_0) => rangeDecorationState_0.length > 0 ? [] : rangeDecorationState_0);
  }, [portableTextEditor, rangeDecorations, schemaTypes, slateEditor]);
  useEffect(() => {
    const onReady = editorActor.on("ready", () => {
      syncRangeDecorations(), restoreSelectionFromProps();
    }), onInvalidValue = editorActor.on("invalid value", () => {
      setHasInvalidValue(!0);
    }), onValueChanged = editorActor.on("value changed", () => {
      setHasInvalidValue(!1);
    });
    return () => {
      onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();
    };
  }, [editorActor, restoreSelectionFromProps, syncRangeDecorations]), useEffect(() => {
    propsSelection && !hasInvalidValue && restoreSelectionFromProps();
  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);
  const [syncedRangeDecorations, setSyncedRangeDecorations] = useState(!1);
  useEffect(() => {
    syncedRangeDecorations || (setSyncedRangeDecorations(!0), syncRangeDecorations());
  }, [syncRangeDecorations, syncedRangeDecorations]), useEffect(() => {
    isEqual(rangeDecorations, rangeDecorationsRef.current) || syncRangeDecorations(), rangeDecorationsRef.current = rangeDecorations;
  }, [rangeDecorations, syncRangeDecorations]), useEffect(() => {
    const teardown = withSyncRangeDecorations({
      editorActor,
      slateEditor,
      syncRangeDecorations
    });
    return () => teardown();
  }, [editorActor, slateEditor, syncRangeDecorations]);
  const handleCopy = useCallback((event) => {
    if (onCopy)
      onCopy(event) !== void 0 && event.preventDefault();
    else if (event.nativeEvent.clipboardData) {
      event.stopPropagation(), event.preventDefault();
      const position = getEventPosition({
        snapshot: getEditorSnapshot({
          editorActorSnapshot: editorActor.getSnapshot(),
          slateEditorInstance: slateEditor
        }),
        slateEditor,
        event: event.nativeEvent
      });
      if (!position) {
        console.warn("Could not find position for copy event");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "clipboard.copy",
          originEvent: {
            dataTransfer: event.nativeEvent.clipboardData
          },
          position
        },
        editor: slateEditor,
        nativeEvent: event
      });
    }
  }, [onCopy, editorActor, slateEditor]), handleCut = useCallback((event_0) => {
    if (onCut)
      onCut(event_0) !== void 0 && event_0.preventDefault();
    else if (event_0.nativeEvent.clipboardData) {
      event_0.stopPropagation(), event_0.preventDefault();
      const position_0 = getEventPosition({
        snapshot: getEditorSnapshot({
          editorActorSnapshot: editorActor.getSnapshot(),
          slateEditorInstance: slateEditor
        }),
        slateEditor,
        event: event_0.nativeEvent
      });
      if (!position_0) {
        console.warn("Could not find position for cut event");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "clipboard.cut",
          originEvent: {
            dataTransfer: event_0.nativeEvent.clipboardData
          },
          position: position_0
        },
        editor: slateEditor,
        nativeEvent: event_0
      });
    }
  }, [onCut, editorActor, slateEditor]), handlePaste = useCallback((event_1) => {
    const value_0 = PortableTextEditor.getValue(portableTextEditor), path = toPortableTextRange(value_0, slateEditor.selection, schemaTypes)?.focus.path || [], onPasteResult = onPaste?.({
      event: event_1,
      value: value_0,
      path,
      schemaTypes
    });
    if (onPasteResult || !slateEditor.selection)
      event_1.preventDefault(), editorActor.send({
        type: "notify.loading"
      }), Promise.resolve(onPasteResult).then((result_1) => {
        if (debug("Custom paste function from client resolved", result_1), !result_1 || !result_1.insert) {
          debug("No result from custom paste handler, pasting normally");
          const position_1 = getEventPosition({
            snapshot: getEditorSnapshot({
              editorActorSnapshot: editorActor.getSnapshot(),
              slateEditorInstance: slateEditor
            }),
            slateEditor,
            event: event_1.nativeEvent
          });
          if (!position_1) {
            console.warn("Could not find position for paste event");
            return;
          }
          editorActor.send({
            type: "behavior event",
            behaviorEvent: {
              type: "clipboard.paste",
              originEvent: {
                dataTransfer: event_1.clipboardData
              },
              position: position_1
            },
            editor: slateEditor,
            nativeEvent: event_1
          });
        } else result_1.insert ? editorActor.send({
          type: "behavior event",
          behaviorEvent: {
            type: "insert.blocks",
            blocks: parseBlocks({
              context: {
                keyGenerator: editorActor.getSnapshot().context.keyGenerator,
                schema: editorActor.getSnapshot().context.schema
              },
              blocks: result_1.insert,
              options: {
                refreshKeys: !0
              }
            }),
            placement: "auto"
          },
          editor: slateEditor
        }) : console.warn("Your onPaste function returned something unexpected:", result_1);
      }).catch((error) => (console.warn(error), error)).finally(() => {
        editorActor.send({
          type: "notify.done loading"
        });
      });
    else if (event_1.nativeEvent.clipboardData) {
      event_1.preventDefault(), event_1.stopPropagation();
      const position_2 = getEventPosition({
        snapshot: getEditorSnapshot({
          editorActorSnapshot: editorActor.getSnapshot(),
          slateEditorInstance: slateEditor
        }),
        slateEditor,
        event: event_1.nativeEvent
      });
      if (!position_2) {
        console.warn("Could not find position for paste event");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "clipboard.paste",
          originEvent: {
            dataTransfer: event_1.nativeEvent.clipboardData
          },
          position: position_2
        },
        editor: slateEditor,
        nativeEvent: event_1
      });
    }
    debug("No result from custom paste handler, pasting normally");
  }, [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor]), handleOnFocus = useCallback((event_2) => {
    if (onFocus && onFocus(event_2), !event_2.isDefaultPrevented()) {
      const selection = PortableTextEditor.getSelection(portableTextEditor);
      selection === null && (Transforms.select(slateEditor, Editor.start(slateEditor, [])), slateEditor.onChange()), editorActor.send({
        type: "notify.focused",
        event: event_2
      });
      const newSelection = PortableTextEditor.getSelection(portableTextEditor);
      selection === newSelection && editorActor.send({
        type: "notify.selection",
        selection
      });
    }
  }, [editorActor, onFocus, portableTextEditor, slateEditor]), handleClick = useCallback((event_3) => {
    if (onClick && onClick(event_3), event_3.isDefaultPrevented() || event_3.isPropagationStopped())
      return;
    const position_3 = getEventPosition({
      snapshot: getEditorSnapshot({
        editorActorSnapshot: editorActor.getSnapshot(),
        slateEditorInstance: slateEditor
      }),
      slateEditor,
      event: event_3.nativeEvent
    });
    if (!position_3) {
      console.warn("Could not find EventPosition for MouseEvent");
      return;
    }
    editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "mouse.click",
        position: position_3
      },
      editor: slateEditor,
      nativeEvent: event_3
    });
  }, [onClick, editorActor, slateEditor]), handleOnBlur = useCallback((event_4) => {
    onBlur && onBlur(event_4), event_4.isPropagationStopped() || editorActor.send({
      type: "notify.blurred",
      event: event_4
    });
  }, [editorActor, onBlur]), handleOnBeforeInput = useCallback((event_5) => {
    onBeforeInput && onBeforeInput(event_5);
  }, [onBeforeInput]), validateSelection = useCallback(() => {
    if (!slateEditor.selection)
      return;
    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor), {
      activeElement
    } = root;
    if (ref.current !== activeElement)
      return;
    const domSelection = ReactEditor.getWindow(slateEditor).getSelection();
    if (!domSelection || domSelection.rangeCount === 0)
      return;
    const existingDOMRange = domSelection.getRangeAt(0);
    try {
      const newDOMRange = ReactEditor.toDOMRange(slateEditor, slateEditor.selection);
      (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug("DOM range out of sync, validating selection"), domSelection?.removeAllRanges(), domSelection.addRange(newDOMRange));
    } catch {
      debug("Could not resolve selection, selecting top document"), Transforms.deselect(slateEditor), slateEditor.children.length > 0 && Transforms.select(slateEditor, [0, 0]), slateEditor.onChange();
    }
  }, [ref, slateEditor]);
  useEffect(() => {
    if (editableElement) {
      const mutationObserver = new MutationObserver(validateSelection);
      return mutationObserver.observe(editableElement, {
        attributeOldValue: !1,
        attributes: !1,
        characterData: !1,
        childList: !0,
        subtree: !0
      }), () => {
        mutationObserver.disconnect();
      };
    }
  }, [validateSelection, editableElement]);
  const handleKeyDown = useCallback((event_6) => {
    props.onKeyDown && props.onKeyDown(event_6), event_6.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_6), event_6.isDefaultPrevented() || editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "keyboard.keydown",
        originEvent: {
          key: event_6.key,
          code: event_6.code,
          altKey: event_6.altKey,
          ctrlKey: event_6.ctrlKey,
          metaKey: event_6.metaKey,
          shiftKey: event_6.shiftKey
        }
      },
      editor: slateEditor,
      nativeEvent: event_6
    });
  }, [props, editorActor, slateEditor]), handleKeyUp = useCallback((event_7) => {
    props.onKeyUp && props.onKeyUp(event_7), event_7.isDefaultPrevented() || editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "keyboard.keyup",
        originEvent: {
          key: event_7.key,
          code: event_7.code,
          altKey: event_7.altKey,
          ctrlKey: event_7.ctrlKey,
          metaKey: event_7.metaKey,
          shiftKey: event_7.shiftKey
        }
      },
      editor: slateEditor,
      nativeEvent: event_7
    });
  }, [props, editorActor, slateEditor]), scrollSelectionIntoViewToSlate = useMemo(() => {
    if (scrollSelectionIntoView !== void 0)
      return scrollSelectionIntoView === null ? noop : (_editor, domRange) => {
        scrollSelectionIntoView(portableTextEditor, domRange);
      };
  }, [portableTextEditor, scrollSelectionIntoView]), decorate = useCallback(([, path_0]) => {
    if (isEqualToEmptyEditor(slateEditor.children, schemaTypes))
      return [{
        anchor: {
          path: [0, 0],
          offset: 0
        },
        focus: {
          path: [0, 0],
          offset: 0
        },
        placeholder: !0
      }];
    if (path_0.length === 0)
      return [];
    const result_2 = rangeDecorationState.filter((item) => Range.isCollapsed(item) ? path_0.length !== 2 ? !1 : Path.equals(item.focus.path, path_0) && Path.equals(item.anchor.path, path_0) : Range.intersection(item, {
      anchor: {
        path: path_0,
        offset: 0
      },
      focus: {
        path: path_0,
        offset: 0
      }
    }) || Range.includes(item, path_0));
    return result_2.length > 0 ? result_2 : [];
  }, [slateEditor, schemaTypes, rangeDecorationState]);
  useEffect(() => {
    ref.current = ReactEditor.toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);
  }, [slateEditor, ref]), useEffect(() => {
    const window_0 = ReactEditor.getWindow(slateEditor), onDragEnd_0 = () => {
      editorActor.send({
        type: "dragend"
      });
    }, onDrop_0 = () => {
      editorActor.send({
        type: "drop"
      });
    };
    return window_0.document.addEventListener("dragend", onDragEnd_0), window_0.document.addEventListener("drop", onDrop_0), () => {
      window_0.document.removeEventListener("dragend", onDragEnd_0), window_0.document.removeEventListener("drop", onDrop_0);
    };
  }, [slateEditor, editorActor]);
  const handleDragStart = useCallback((event_8) => {
    if (onDragStart?.(event_8), !event_8.isDefaultPrevented() && !event_8.isPropagationStopped()) {
      const position_4 = getEventPosition({
        snapshot: getEditorSnapshot({
          editorActorSnapshot: editorActor.getSnapshot(),
          slateEditorInstance: slateEditor
        }),
        slateEditor,
        event: event_8.nativeEvent
      });
      if (!position_4) {
        console.warn("Could not find position for dragstart event");
        return;
      }
      if (ReactEditor.hasTarget(slateEditor, event_8.target)) {
        const node = ReactEditor.toSlateNode(slateEditor, event_8.target), path_1 = ReactEditor.findPath(slateEditor, node);
        if (Element$1.isElement(node) && Editor.isVoid(slateEditor, node) || Editor.void(slateEditor, {
          at: path_1,
          voids: !0
        })) {
          const range = Editor.range(slateEditor, path_1);
          Transforms.select(slateEditor, range);
        }
      }
      editorActor.send({
        type: "dragstart",
        origin: position_4
      }), editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "drag.dragstart",
          originEvent: {
            dataTransfer: event_8.dataTransfer
          },
          position: position_4
        },
        editor: slateEditor
      }), event_8.stopPropagation();
    }
  }, [onDragStart, editorActor, slateEditor]), handleDrag = useCallback((event_9) => {
    onDrag?.(event_9), !event_9.isDefaultPrevented() && !event_9.isPropagationStopped() && (editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "drag.drag",
        originEvent: {
          dataTransfer: event_9.dataTransfer
        }
      },
      editor: slateEditor
    }), event_9.stopPropagation());
  }, [onDrag, editorActor, slateEditor]), handleDragEnd = useCallback((event_10) => {
    onDragEnd?.(event_10), !event_10.isDefaultPrevented() && !event_10.isPropagationStopped() && (editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "drag.dragend",
        originEvent: {
          dataTransfer: event_10.dataTransfer
        }
      },
      editor: slateEditor
    }), event_10.stopPropagation());
  }, [onDragEnd, editorActor, slateEditor]), handleDragEnter = useCallback((event_11) => {
    if (onDragEnter?.(event_11), !event_11.isDefaultPrevented() && !event_11.isPropagationStopped()) {
      const position_5 = getEventPosition({
        snapshot: getEditorSnapshot({
          editorActorSnapshot: editorActor.getSnapshot(),
          slateEditorInstance: slateEditor
        }),
        slateEditor,
        event: event_11.nativeEvent
      });
      if (!position_5)
        return;
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "drag.dragenter",
          originEvent: {
            dataTransfer: event_11.dataTransfer
          },
          position: position_5
        },
        editor: slateEditor
      }), event_11.stopPropagation();
    }
  }, [onDragEnter, editorActor, slateEditor]), handleDragOver = useCallback((event_12) => {
    if (onDragOver?.(event_12), !event_12.isDefaultPrevented() && !event_12.isPropagationStopped()) {
      const position_6 = getEventPosition({
        snapshot: getEditorSnapshot({
          editorActorSnapshot: editorActor.getSnapshot(),
          slateEditorInstance: slateEditor
        }),
        slateEditor,
        event: event_12.nativeEvent
      });
      if (!position_6)
        return;
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "drag.dragover",
          originEvent: {
            dataTransfer: event_12.dataTransfer
          },
          position: position_6
        },
        editor: slateEditor,
        nativeEvent: event_12
      }), event_12.stopPropagation();
    }
  }, [onDragOver, editorActor, slateEditor]), handleDrop = useCallback((event_13) => {
    if (onDrop?.(event_13), !event_13.isDefaultPrevented() && !event_13.isPropagationStopped()) {
      const position_7 = getEventPosition({
        snapshot: getEditorSnapshot({
          editorActorSnapshot: editorActor.getSnapshot(),
          slateEditorInstance: slateEditor
        }),
        slateEditor,
        event: event_13.nativeEvent
      });
      if (!position_7) {
        console.warn("Could not find position for drop event");
        return;
      }
      const range_0 = ReactEditor.findEventRange(slateEditor, event_13);
      slateEditor.select(range_0), editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "drag.drop",
          originEvent: {
            dataTransfer: event_13.dataTransfer
          },
          position: position_7
        },
        editor: slateEditor
      }), event_13.preventDefault();
    }
  }, [onDrop, editorActor, slateEditor]), handleDragLeave = useCallback((event_14) => {
    onDragLeave?.(event_14), !event_14.isDefaultPrevented() && !event_14.isPropagationStopped() && editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "drag.dragleave",
        originEvent: {
          dataTransfer: event_14.dataTransfer
        }
      },
      editor: slateEditor
    });
  }, [onDragLeave, editorActor, slateEditor]);
  return portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ jsx(
    Editable,
    {
      ...restProps,
      autoFocus: !1,
      className: restProps.className || "pt-editable",
      decorate,
      onBlur: handleOnBlur,
      onCopy: handleCopy,
      onCut: handleCut,
      onClick: handleClick,
      onDOMBeforeInput: handleOnBeforeInput,
      onDragStart: handleDragStart,
      onDrag: handleDrag,
      onDragEnd: handleDragEnd,
      onDragEnter: handleDragEnter,
      onDragOver: handleDragOver,
      onDrop: handleDrop,
      onDragLeave: handleDragLeave,
      onFocus: handleOnFocus,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onPaste: handlePaste,
      readOnly,
      renderPlaceholder: void 0,
      renderElement,
      renderLeaf,
      scrollSelectionIntoView: scrollSelectionIntoViewToSlate
    }
  ) : null;
});
PortableTextEditable.displayName = "ForwardRef(PortableTextEditable)";
function EditorEventListener(props) {
  const $ = c(5), editor = useEditor(), on = useEffectEvent(props.on);
  let t0;
  $[0] !== editor || $[1] !== on ? (t0 = () => {
    const subscription = editor.on("*", on);
    return () => {
      subscription.unsubscribe();
    };
  }, $[0] = editor, $[1] = on, $[2] = t0) : t0 = $[2];
  let t1;
  return $[3] !== editor ? (t1 = [editor], $[3] = editor, $[4] = t1) : t1 = $[4], useEffect(t0, t1), null;
}
export {
  EditorEventListener,
  EditorProvider,
  PortableTextEditable,
  PortableTextEditor,
  defineSchema,
  defaultKeyGenerator as keyGenerator,
  useEditor,
  useEditorSelector,
  usePortableTextEditor,
  usePortableTextEditorSelection
};
//# sourceMappingURL=index.js.map
