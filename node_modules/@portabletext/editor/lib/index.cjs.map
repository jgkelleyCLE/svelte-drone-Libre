{"version":3,"file":"index.cjs","sources":["../src/internal-utils/event-position.ts","../src/internal-utils/selection.ts","../src/editor/components/DefaultObject.tsx","../src/editor/components/drop-indicator.tsx","../src/editor/components/use-draggable.ts","../src/editor/components/Element.tsx","../src/editor/components/Leaf.tsx","../src/editor/plugins/createWithHotKeys.ts","../src/editor/withSyncRangeDecorations.ts","../src/editor/Editable.tsx","../src/editor-event-listener.tsx"],"sourcesContent":["import {Editor, type BaseRange} from 'slate'\nimport {DOMEditor, isDOMNode} from 'slate-dom'\nimport {ReactEditor} from 'slate-react'\nimport type {EditorSelection, EditorSnapshot} from '..'\nimport * as selectors from '../selectors'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport * as utils from '../utils'\nimport {toPortableTextRange} from './ranges'\n\nexport type EventPosition = {\n  block: 'start' | 'end'\n  /**\n   * Did the event origin from the editor DOM node itself or from a child node?\n   */\n  isEditor: boolean\n  selection: NonNullable<EditorSelection>\n}\nexport type EventPositionBlock = EventPosition['block']\n\nexport function getEventPosition({\n  snapshot,\n  slateEditor,\n  event,\n}: {\n  snapshot: EditorSnapshot\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | ClipboardEvent | MouseEvent\n}): EventPosition | undefined {\n  if (!DOMEditor.hasTarget(slateEditor, event.target)) {\n    return undefined\n  }\n\n  const node = DOMEditor.toSlateNode(slateEditor, event.target)\n\n  if (isClipboardEvent(event)) {\n    const selection = snapshot.context.selection\n\n    if (!selection) {\n      return undefined\n    }\n\n    return {\n      block: 'end',\n      isEditor: Editor.isEditor(node),\n      selection,\n    }\n  }\n\n  const block = getEventPositionBlock({slateEditor, event})\n  const selection = getEventPositionSelection({snapshot, slateEditor, event})\n\n  if (!block || !selection) {\n    return undefined\n  }\n\n  return {\n    block,\n    isEditor: Editor.isEditor(node),\n    selection,\n  }\n}\n\nfunction getEventPositionBlock({\n  slateEditor,\n  event,\n}: {\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPositionBlock | undefined {\n  if (!ReactEditor.hasTarget(slateEditor, event.target)) {\n    return undefined\n  }\n\n  const node = ReactEditor.toSlateNode(slateEditor, event.target)\n  const element = ReactEditor.toDOMNode(slateEditor, node)\n  const elementRect = element.getBoundingClientRect()\n  const top = elementRect.top\n  const height = elementRect.height\n  const location = Math.abs(top - event.pageY)\n\n  return location < height / 2 ? 'start' : 'end'\n}\n\nfunction getEventPositionSelection({\n  snapshot,\n  slateEditor,\n  event,\n}: {\n  snapshot: EditorSnapshot\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EditorSelection {\n  const range = getSlateRangeFromEvent(slateEditor, event)\n\n  const selection = range\n    ? toPortableTextRange(\n        snapshot.context.value,\n        range,\n        snapshot.context.schema,\n      )\n    : null\n\n  if (!selection) {\n    return selection\n  }\n\n  const collapsedSelection = selectors.isSelectionCollapsed({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const focusTextBlock = selectors.getFocusTextBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const focusSpan = selectors.getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n\n  if (\n    event.type === 'dragstart' &&\n    collapsedSelection &&\n    focusTextBlock &&\n    focusSpan\n  ) {\n    // Looks like we are dragging an empty span. Let's drag the entire block\n    // instead\n\n    const blockStartPoint = utils.getBlockStartPoint(focusTextBlock)\n    const blockEndPoint = utils.getBlockEndPoint(focusTextBlock)\n\n    return {\n      anchor: blockStartPoint,\n      focus: blockEndPoint,\n    }\n  }\n\n  return selection\n}\n\nfunction getSlateRangeFromEvent(\n  editor: PortableTextSlateEditor,\n  event: DragEvent | MouseEvent,\n) {\n  if (!event.target) {\n    return undefined\n  }\n\n  if (!isDOMNode(event.target)) {\n    return undefined\n  }\n\n  const window = DOMEditor.getWindow(editor)\n\n  let domRange: Range | undefined\n\n  if (window.document.caretPositionFromPoint !== undefined) {\n    const position = window.document.caretPositionFromPoint(\n      event.clientX,\n      event.clientY,\n    )\n\n    if (position) {\n      domRange = window.document.createRange()\n      domRange.setStart(position.offsetNode, position.offset)\n      domRange.setEnd(position.offsetNode, position.offset)\n    }\n  } else if (window.document.caretRangeFromPoint !== undefined) {\n    // Use WebKit-proprietary fallback method\n    domRange =\n      window.document.caretRangeFromPoint(event.clientX, event.clientY) ??\n      undefined\n  } else {\n    console.warn(\n      'Neither caretPositionFromPoint nor caretRangeFromPoint is supported',\n    )\n    return undefined\n  }\n\n  if (!domRange) {\n    return undefined\n  }\n\n  let range: BaseRange | undefined\n\n  try {\n    range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      // It can still throw even with this option set to true\n      suppressThrow: false,\n    })\n  } catch {}\n\n  return range\n}\n\nfunction isClipboardEvent(\n  event: DragEvent | ClipboardEvent | MouseEvent,\n): event is ClipboardEvent {\n  return event.type === 'copy' || event.type === 'cut' || event.type === 'paste'\n}\n","import type {Path, PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\nexport function normalizePoint(\n  point: EditorSelectionPoint,\n  value: PortableTextBlock[],\n): EditorSelectionPoint | null {\n  if (!point || !value) {\n    return null\n  }\n  const newPath: Path = []\n  let newOffset: number = point.offset || 0\n  const blockKey =\n    typeof point.path[0] === 'object' &&\n    '_key' in point.path[0] &&\n    point.path[0]._key\n  const childKey =\n    typeof point.path[2] === 'object' &&\n    '_key' in point.path[2] &&\n    point.path[2]._key\n  const block: PortableTextBlock | undefined = value.find(\n    (blk) => blk._key === blockKey,\n  )\n  if (block) {\n    newPath.push({_key: block._key})\n  } else {\n    return null\n  }\n  if (block && point.path[1] === 'children') {\n    if (\n      !block.children ||\n      (Array.isArray(block.children) && block.children.length === 0)\n    ) {\n      return null\n    }\n    const child =\n      Array.isArray(block.children) &&\n      block.children.find((cld) => cld._key === childKey)\n    if (child) {\n      newPath.push('children')\n      newPath.push({_key: child._key})\n      newOffset =\n        child.text && child.text.length >= point.offset\n          ? point.offset\n          : (child.text && child.text.length) || 0\n    } else {\n      return null\n    }\n  }\n  return {path: newPath, offset: newOffset}\n}\n\nexport function normalizeSelection(\n  selection: EditorSelection,\n  value: PortableTextBlock[] | undefined,\n): EditorSelection | null {\n  if (!selection || !value || value.length === 0) {\n    return null\n  }\n  let newAnchor: EditorSelectionPoint | null = null\n  let newFocus: EditorSelectionPoint | null = null\n  const {anchor, focus} = selection\n  if (\n    anchor &&\n    value.find((blk) => isEqual({_key: blk._key}, anchor.path[0]))\n  ) {\n    newAnchor = normalizePoint(anchor, value)\n  }\n  if (focus && value.find((blk) => isEqual({_key: blk._key}, focus.path[0]))) {\n    newFocus = normalizePoint(focus, value)\n  }\n  if (newAnchor && newFocus) {\n    return {anchor: newAnchor, focus: newFocus, backward: selection.backward}\n  }\n  return null\n}\n","import type {PortableTextBlock, PortableTextChild} from '@sanity/types'\n\nexport function DefaultBlockObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <div style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </div>\n  )\n}\n\nexport function DefaultInlineObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <span style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </span>\n  )\n}\n","export function DropIndicator() {\n  return (\n    <div\n      className=\"pt-drop-indicator\"\n      style={{\n        position: 'absolute',\n        width: '100%',\n        height: 1,\n        borderBottom: '1px solid currentColor',\n        zIndex: 5,\n      }}\n    />\n  )\n}\n","import {\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n  type DragEvent,\n  type RefObject,\n} from 'react'\nimport type {Element as SlateElement} from 'slate'\nimport {ReactEditor, useSlateStatic} from 'slate-react'\nimport {getEventPosition} from '../../internal-utils/event-position'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {getEditorSnapshot} from '../editor-selector'\n\ntype Draggable = {\n  draggableProps: {\n    draggable: boolean\n    onDragStart?: (event: DragEvent) => void\n    onDragEnd?: (event: DragEvent) => void\n  }\n}\n\nexport function useDraggable(props: {\n  element: SlateElement\n  readOnly: boolean\n  blockRef: RefObject<HTMLDivElement | null>\n}): Draggable {\n  const editorActor = useContext(EditorActorContext)\n  const editor = useSlateStatic()\n  const [blockElement, setBlockElement] = useState<HTMLElement | null>(null)\n\n  useEffect(\n    () =>\n      setBlockElement(\n        props.blockRef\n          ? props.blockRef.current\n          : ReactEditor.toDOMNode(editor, props.element),\n      ),\n    [editor, props.element, props.blockRef],\n  )\n\n  const handleDragEnd = useCallback(() => {\n    editorActor.send({type: 'dragend'})\n  }, [editorActor])\n\n  const handleDragStart = useCallback(\n    (event: DragEvent) => {\n      const position = getEventPosition({\n        snapshot: getEditorSnapshot({\n          editorActorSnapshot: editorActor.getSnapshot(),\n          slateEditorInstance: editor,\n        }),\n        slateEditor: editor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.error('Could not find position for dragstart event')\n        return\n      }\n\n      // Clone blockElement so that it will not be visually clipped by scroll-containers etc.\n      // The application that uses the portable-text-editor may indicate the element used as\n      // drag ghost by adding a truthy data attribute 'data-pt-drag-ghost-element' to a HTML element.\n      if (blockElement && blockElement instanceof HTMLElement) {\n        let dragGhost = blockElement.cloneNode(true) as HTMLElement\n        const customGhost = dragGhost.querySelector(\n          '[data-pt-drag-ghost-element]',\n        )\n        if (customGhost) {\n          dragGhost = customGhost as HTMLElement\n        }\n\n        // Set the `data-dragged` attribute so the consumer can style the element while itâ€™s dragged\n        dragGhost.setAttribute('data-dragged', '')\n\n        if (document.body) {\n          dragGhost.style.position = 'absolute'\n          dragGhost.style.left = '-99999px'\n          dragGhost.style.boxSizing = 'border-box'\n          document.body.appendChild(dragGhost)\n          const rect = blockElement.getBoundingClientRect()\n          const x = event.clientX - rect.left\n          const y = event.clientY - rect.top\n          dragGhost.style.width = `${rect.width}px`\n          dragGhost.style.height = `${rect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n\n          editorActor.send({\n            type: 'dragstart',\n            origin: position,\n            ghost: dragGhost,\n          })\n          return\n        }\n\n        editorActor.send({\n          type: 'dragstart',\n          origin: position,\n        })\n      }\n    },\n    [blockElement, editor, editorActor],\n  )\n\n  if (props.readOnly) {\n    return {\n      draggableProps: {\n        draggable: false,\n        onDragStart: undefined,\n        onDragEnd: undefined,\n      },\n    }\n  }\n\n  return {\n    draggableProps: {\n      draggable: true,\n      onDragStart: handleDragStart,\n      onDragEnd: handleDragEnd,\n    },\n  }\n}\n","import type {\n  Path,\n  PortableTextChild,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type FunctionComponent,\n  type JSX,\n  type ReactElement,\n} from 'react'\nimport {Editor, Range, Element as SlateElement} from 'slate'\nimport {\n  ReactEditor,\n  useSelected,\n  useSlateStatic,\n  type RenderElementProps,\n} from 'slate-react'\nimport {defineBehavior} from '../../behaviors'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport {fromSlateValue} from '../../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../../internal-utils/weakMaps'\nimport * as selectors from '../../selectors'\nimport type {\n  BlockRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {DefaultBlockObject, DefaultInlineObject} from './DefaultObject'\nimport {DropIndicator} from './drop-indicator'\nimport {useDraggable} from './use-draggable'\n\nconst debug = debugWithName('components:Element')\nconst debugRenders = false\nconst EMPTY_ANNOTATIONS: PortableTextObject[] = []\n\n/**\n * @internal\n */\nexport interface ElementProps {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement<any>\n  element: SlateElement\n  schemaTypes: PortableTextMemberSchemaTypes\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n}\n\nconst inlineBlockStyle = {display: 'inline-block'}\n\n/**\n * Renders Portable Text block and inline object nodes in Slate\n * @internal\n */\nexport const Element: FunctionComponent<ElementProps> = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck,\n}) => {\n  const editorActor = useContext(EditorActorContext)\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n  const blockRef = useRef<HTMLDivElement | null>(null)\n  const inlineBlockObjectRef = useRef(null)\n  const focused =\n    (selected &&\n      slateEditor.selection &&\n      Range.isCollapsed(slateEditor.selection)) ||\n    false\n  const [dragPositionBlock, setDragPositionBlock] =\n    useState<EventPositionBlock>()\n  const draggable = useDraggable({element, readOnly, blockRef})\n\n  useEffect(() => {\n    const behavior = defineBehavior({\n      on: 'drag.dragover',\n      guard: ({snapshot, event}) => {\n        const dropFocusBlock = selectors.getFocusBlock({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: event.position.selection,\n          },\n        })\n\n        if (!dropFocusBlock || dropFocusBlock.node._key !== element._key) {\n          return false\n        }\n\n        const dragOrigin = snapshot.beta.internalDrag?.origin\n\n        if (!dragOrigin) {\n          return false\n        }\n\n        const draggedBlocks = selectors.getSelectedBlocks({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection,\n          },\n        })\n\n        if (\n          draggedBlocks.some(\n            (draggedBlock) => draggedBlock.node._key === element._key,\n          )\n        ) {\n          return false\n        }\n\n        const draggingEntireBlocks = selectors.isSelectingEntireBlocks({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection,\n          },\n        })\n\n        return draggingEntireBlocks\n      },\n      actions: [\n        ({event}) => [\n          {\n            type: 'effect',\n            effect: () => {\n              setDragPositionBlock(event.position.block)\n            },\n          },\n          {\n            type: 'noop',\n          },\n        ],\n      ],\n    })\n\n    editorActor.send({\n      type: 'add behavior',\n      behavior,\n    })\n\n    return () => {\n      editorActor.send({\n        type: 'remove behavior',\n        behavior,\n      })\n    }\n  }, [editorActor, element._key])\n\n  useEffect(() => {\n    const behavior = defineBehavior({\n      on: 'drag.*',\n      guard: ({event}) => {\n        return event.type !== 'drag.dragover'\n      },\n      actions: [\n        () => [\n          {\n            type: 'effect',\n            effect: () => {\n              setDragPositionBlock(undefined)\n            },\n          },\n        ],\n      ],\n    })\n\n    editorActor.send({\n      type: 'add behavior',\n      behavior,\n    })\n\n    return () => {\n      editorActor.send({\n        type: 'remove behavior',\n        behavior,\n      })\n    }\n  }, [editorActor])\n\n  const value = useMemo(\n    () =>\n      fromSlateValue(\n        [element],\n        schemaTypes.block.name,\n        KEY_TO_VALUE_ELEMENT.get(slateEditor),\n      )[0],\n    [slateEditor, element, schemaTypes.block.name],\n  )\n\n  let renderedBlock = children\n\n  let className: string | undefined\n\n  const blockPath: Path = useMemo(() => [{_key: element._key}], [element])\n\n  if (typeof element._type !== 'string') {\n    throw new Error(`Expected element to have a _type property`)\n  }\n\n  if (typeof element._key !== 'string') {\n    throw new Error(`Expected element to have a _key property`)\n  }\n\n  // Test for inline objects first\n  if (slateEditor.isInline(element)) {\n    const path = ReactEditor.findPath(slateEditor, element)\n    const [block] = Editor.node(slateEditor, path, {depth: 1})\n    const schemaType = schemaTypes.inlineObjects.find(\n      (_type) => _type.name === element._type,\n    )\n    if (!schemaType) {\n      throw new Error('Could not find type for inline block element')\n    }\n    if (SlateElement.isElement(block)) {\n      const elmPath: Path = [\n        {_key: block._key},\n        'children',\n        {_key: element._key},\n      ]\n      if (debugRenders) {\n        debug(`Render ${element._key} (inline object)`)\n      }\n      return (\n        <span {...attributes}>\n          {/* Note that children must follow immediately or cut and selections will not work properly in Chrome. */}\n          {children}\n          <span\n            draggable={!readOnly}\n            className=\"pt-inline-object\"\n            data-testid=\"pt-inline-object\"\n            ref={inlineBlockObjectRef}\n            key={element._key}\n            style={inlineBlockStyle}\n            contentEditable={false}\n          >\n            {renderChild &&\n              renderChild({\n                annotations: EMPTY_ANNOTATIONS, // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n                children: <DefaultInlineObject value={value} />,\n                editorElementRef: inlineBlockObjectRef,\n                focused,\n                path: elmPath,\n                schemaType,\n                selected,\n                type: schemaType,\n                value: value as PortableTextChild,\n              })}\n            {!renderChild && <DefaultInlineObject value={value} />}\n          </span>\n        </span>\n      )\n    }\n    throw new Error('Block not found!')\n  }\n\n  // If not inline, it's either a block (text) or a block object (non-text)\n  // NOTE: text blocks aren't draggable with DraggableBlock (yet?)\n  if (element._type === schemaTypes.block.name) {\n    className = `pt-block pt-text-block`\n    const isListItem = 'listItem' in element\n    if (debugRenders) {\n      debug(`Render ${element._key} (text block)`)\n    }\n    const style = ('style' in element && element.style) || 'normal'\n    className = `pt-block pt-text-block pt-text-block-style-${style}`\n    const blockStyleType = schemaTypes.styles.find(\n      (item) => item.value === style,\n    )\n    if (renderStyle && blockStyleType) {\n      renderedBlock = renderStyle({\n        block: element as PortableTextTextBlock,\n        children,\n        focused,\n        selected,\n        value: style,\n        path: blockPath,\n        schemaType: blockStyleType,\n        editorElementRef: blockRef,\n      })\n    }\n    let level: number | undefined\n\n    if (isListItem) {\n      if (typeof element.level === 'number') {\n        level = element.level\n      }\n      className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`\n    }\n\n    if (slateEditor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find(\n        (item) => item.value === element.listItem,\n      )\n      if (renderListItem && listType) {\n        renderedBlock = renderListItem({\n          block: value,\n          children: renderedBlock,\n          focused,\n          selected,\n          value: element.listItem,\n          path: blockPath,\n          schemaType: listType,\n          level: value.level || 1,\n          editorElementRef: blockRef,\n        })\n      }\n    }\n\n    const renderProps: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: renderedBlock,\n        editorElementRef: blockRef,\n        focused,\n        level,\n        listItem: isListItem ? element.listItem : undefined,\n        path: blockPath,\n        selected,\n        style,\n        schemaType: schemaTypes.block,\n        value,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaTypes.block\n        },\n      },\n    )\n\n    const propsOrDefaultRendered = renderBlock\n      ? renderBlock(renderProps as BlockRenderProps)\n      : children\n\n    return (\n      <div\n        key={element._key}\n        {...attributes}\n        className={className}\n        spellCheck={spellCheck}\n      >\n        {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n        <div ref={blockRef}>{propsOrDefaultRendered}</div>\n        {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n      </div>\n    )\n  }\n\n  const schemaType = schemaTypes.blockObjects.find(\n    (_type) => _type.name === element._type,\n  )\n\n  if (!schemaType) {\n    throw new Error(\n      `Could not find schema type for block element of _type ${element._type}`,\n    )\n  }\n\n  if (debugRenders) {\n    debug(`Render ${element._key} (object block)`)\n  }\n\n  className = 'pt-block pt-object-block'\n\n  const block = fromSlateValue(\n    [element],\n    schemaTypes.block.name,\n    KEY_TO_VALUE_ELEMENT.get(slateEditor),\n  )[0]\n\n  let renderedBlockFromProps: JSX.Element | undefined\n\n  if (renderBlock) {\n    const _props: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: <DefaultBlockObject value={value} />,\n        editorElementRef: blockRef,\n        focused,\n        path: blockPath,\n        schemaType,\n        selected,\n        value: block,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaType\n        },\n      },\n    )\n    renderedBlockFromProps = renderBlock(_props as BlockRenderProps)\n  }\n\n  return (\n    <div\n      key={element._key}\n      {...attributes}\n      className={className}\n      {...draggable.draggableProps}\n    >\n      {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n      {children}\n      <div ref={blockRef} contentEditable={false}>\n        {renderedBlockFromProps ? (\n          renderedBlockFromProps\n        ) : (\n          <DefaultBlockObject value={value} />\n        )}\n      </div>\n      {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n    </div>\n  )\n}\n\nElement.displayName = 'Element'\n","import type {\n  Path,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ReactElement,\n} from 'react'\nimport {Text} from 'slate'\nimport {useSelected, type RenderLeafProps} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {\n  BlockAnnotationRenderProps,\n  BlockChildRenderProps,\n  BlockDecoratorRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderAnnotationFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {usePortableTextEditor} from '../hooks/usePortableTextEditor'\nimport {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('components:Leaf')\n\nconst EMPTY_MARKS: string[] = []\n\n/**\n * @internal\n */\nexport interface LeafProps extends RenderLeafProps {\n  editorActor: EditorActor\n  children: ReactElement<any>\n  schemaTypes: PortableTextMemberSchemaTypes\n  renderAnnotation?: RenderAnnotationFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  readOnly: boolean\n}\n\n/**\n * Renders Portable Text span nodes in Slate\n * @internal\n */\nexport const Leaf = (props: LeafProps) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation,\n  } = props\n  const spanRef = useRef<HTMLElement>(null)\n  const portableTextEditor = usePortableTextEditor()\n  const blockSelected = useSelected()\n  const [focused, setFocused] = useState(false)\n  const [selected, setSelected] = useState(false)\n  const block = children.props.parent as PortableTextTextBlock | undefined\n  const path: Path = useMemo(\n    () => (block ? [{_key: block?._key}, 'children', {_key: leaf._key}] : []),\n    [block, leaf._key],\n  )\n  const decoratorValues = useMemo(\n    () => schemaTypes.decorators.map((dec) => dec.value),\n    [schemaTypes.decorators],\n  )\n  const marks: string[] = useMemo(\n    () =>\n      uniq(\n        (leaf.marks || EMPTY_MARKS).filter((mark) =>\n          decoratorValues.includes(mark),\n        ),\n      ),\n    [decoratorValues, leaf.marks],\n  )\n  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS\n  const annotations = useMemo(\n    () =>\n      annotationMarks\n        .map(\n          (mark) =>\n            !decoratorValues.includes(mark) &&\n            block?.markDefs?.find((def) => def._key === mark),\n        )\n        .filter(Boolean) as PortableTextObject[],\n    [annotationMarks, block, decoratorValues],\n  )\n\n  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(false)\n      return\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor)\n    if (\n      sel &&\n      isEqual(sel.focus.path, path) &&\n      PortableTextEditor.isCollapsedSelection(portableTextEditor)\n    ) {\n      startTransition(() => {\n        setFocused(true)\n      })\n    }\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor])\n\n  // Function to check if this leaf is currently inside the user's text selection\n  const setSelectedFromRange = useCallback(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return\n    }\n    debug('Setting selection and focus from range')\n    const winSelection = window.getSelection()\n    if (!winSelection) {\n      setSelected(false)\n      return\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0)\n      if (spanRef.current && range.intersectsNode(spanRef.current)) {\n        setSelected(true)\n      } else {\n        setSelected(false)\n      }\n    } else {\n      setSelected(false)\n    }\n  }, [shouldTrackSelectionAndFocus])\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return undefined\n    }\n\n    const onBlur = editorActor.on('blur', () => {\n      setFocused(false)\n      setSelected(false)\n    })\n\n    const onFocus = editorActor.on('focus', () => {\n      const sel = PortableTextEditor.getSelection(portableTextEditor)\n      if (\n        sel &&\n        isEqual(sel.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      }\n      setSelectedFromRange()\n    })\n\n    const onSelection = editorActor.on('selection', (event) => {\n      if (\n        event.selection &&\n        isEqual(event.selection.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      } else {\n        setFocused(false)\n      }\n      setSelectedFromRange()\n    })\n\n    return () => {\n      onBlur.unsubscribe()\n      onFocus.unsubscribe()\n      onSelection.unsubscribe()\n    }\n  }, [\n    editorActor,\n    path,\n    portableTextEditor,\n    setSelectedFromRange,\n    shouldTrackSelectionAndFocus,\n  ])\n\n  useEffect(() => setSelectedFromRange(), [setSelectedFromRange])\n\n  const content = useMemo(() => {\n    let returnedChildren = children\n    // Render text nodes\n    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name) {\n      marks.forEach((mark) => {\n        const schemaType = schemaTypes.decorators.find(\n          (dec) => dec.value === mark,\n        )\n        if (schemaType && renderDecorator) {\n          const _props: Omit<BlockDecoratorRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                children: returnedChildren,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                selected,\n                schemaType,\n                value: mark,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaType\n                },\n              },\n            )\n          returnedChildren = renderDecorator(\n            _props as BlockDecoratorRenderProps,\n          )\n        }\n      })\n\n      if (block && annotations.length > 0) {\n        annotations.forEach((annotation) => {\n          const schemaType = schemaTypes.annotations.find(\n            (t) => t.name === annotation._type,\n          )\n          if (schemaType) {\n            if (renderAnnotation) {\n              const _props: Omit<BlockAnnotationRenderProps, 'type'> =\n                Object.defineProperty(\n                  {\n                    block,\n                    children: returnedChildren,\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    selected,\n                    schemaType,\n                    value: annotation,\n                  },\n                  'type',\n                  {\n                    enumerable: false,\n                    get() {\n                      console.warn(\n                        \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                      )\n                      return schemaType\n                    },\n                  },\n                )\n\n              returnedChildren = (\n                <span ref={spanRef}>\n                  {renderAnnotation(_props as BlockAnnotationRenderProps)}\n                </span>\n              )\n            } else {\n              returnedChildren = <span ref={spanRef}>{returnedChildren}</span>\n            }\n          }\n        })\n      }\n      if (block && renderChild) {\n        const child = block.children.find((_child) => _child._key === leaf._key) // Ensure object equality\n        if (child) {\n          const defaultRendered = <>{returnedChildren}</>\n          const _props: Omit<BlockChildRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                annotations,\n                children: defaultRendered,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                schemaType: schemaTypes.span,\n                selected,\n                value: child,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaTypes.span\n                },\n              },\n            )\n          returnedChildren = renderChild(_props as BlockChildRenderProps)\n        }\n      }\n    }\n    return returnedChildren\n  }, [\n    annotations,\n    block,\n    children,\n    focused,\n    leaf,\n    marks,\n    path,\n    renderAnnotation,\n    renderChild,\n    renderDecorator,\n    schemaTypes.annotations,\n    schemaTypes.decorators,\n    schemaTypes.span,\n    selected,\n  ])\n  return useMemo(\n    () => (\n      <span key={leaf._key} {...attributes} ref={spanRef}>\n        {content}\n      </span>\n    ),\n    [leaf, attributes, content],\n  )\n}\n\nLeaf.displayName = 'Leaf'\n","import type {KeyboardEvent} from 'react'\nimport type {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isHotkey} from '../../internal-utils/is-hotkey'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {HotkeyOptions} from '../../types/options'\nimport type {EditorActor} from '../editor-machine'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('plugin:withHotKeys')\n\n/**\n * This plugin takes care of all hotkeys in the editor\n *\n */\nexport function createWithHotkeys(\n  editorActor: EditorActor,\n  portableTextEditor: PortableTextEditor,\n  hotkeysFromOptions?: HotkeyOptions,\n): (editor: PortableTextSlateEditor & ReactEditor) => any {\n  const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end']\n  const activeHotkeys = hotkeysFromOptions ?? {}\n  return function withHotKeys(editor: PortableTextSlateEditor & ReactEditor) {\n    editor.pteWithHotKeys = (event: KeyboardEvent<HTMLDivElement>): void => {\n      // Wire up custom marks hotkeys\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === 'marks') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault()\n              const possibleMark = activeHotkeys[cat]\n              if (possibleMark) {\n                const mark = possibleMark[hotkey]\n                debug(`HotKey ${hotkey} to toggle ${mark}`)\n                editorActor.send({\n                  type: 'behavior event',\n                  behaviorEvent: {\n                    type: 'decorator.toggle',\n                    decorator: mark,\n                  },\n                  editor,\n                })\n              }\n            }\n          }\n        }\n        if (cat === 'custom') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat]\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey]\n                command(event, portableTextEditor)\n              }\n            }\n          }\n        }\n      })\n    }\n    return editor\n  }\n}\n","import type {BaseEditor, Operation} from 'slate'\nimport type {ReactEditor} from 'slate-react'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorActor} from './editor-machine'\n\n// React Compiler considers `slateEditor` as immutable, and opts-out if we do this inline in a useEffect, doing it in a function moves it out of the scope, and opts-in again for the rest of the component.\nexport function withSyncRangeDecorations({\n  editorActor,\n  slateEditor,\n  syncRangeDecorations,\n}: {\n  editorActor: EditorActor\n  slateEditor: BaseEditor & ReactEditor & PortableTextSlateEditor\n  syncRangeDecorations: (operation?: Operation) => void\n}) {\n  const originalApply = slateEditor.apply\n\n  slateEditor.apply = (op: Operation) => {\n    originalApply(op)\n\n    if (\n      !editorActor.getSnapshot().matches({'edit mode': 'read only'}) &&\n      op.type !== 'set_selection'\n    ) {\n      syncRangeDecorations(op)\n    }\n  }\n\n  return () => {\n    slateEditor.apply = originalApply\n  }\n}\n","import {useSelector} from '@xstate/react'\nimport {isEqual, noop} from 'lodash'\nimport {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n  type ClipboardEvent,\n  type CSSProperties,\n  type FocusEventHandler,\n  type KeyboardEvent,\n  type MutableRefObject,\n  type TextareaHTMLAttributes,\n} from 'react'\nimport {\n  Editor,\n  Path,\n  Element as SlateElement,\n  Range as SlateRange,\n  Transforms,\n  type BaseRange,\n  type NodeEntry,\n  type Operation,\n  type Text,\n} from 'slate'\nimport {\n  ReactEditor,\n  Editable as SlateEditable,\n  useSlate,\n  type RenderElementProps,\n  type RenderLeafProps,\n} from 'slate-react'\nimport {debugWithName} from '../internal-utils/debug'\nimport {getEventPosition} from '../internal-utils/event-position'\nimport {parseBlocks} from '../internal-utils/parse-blocks'\nimport {\n  moveRangeByOperation,\n  toPortableTextRange,\n  toSlateRange,\n} from '../internal-utils/ranges'\nimport {normalizeSelection} from '../internal-utils/selection'\nimport {fromSlateValue, isEqualToEmptyEditor} from '../internal-utils/values'\nimport type {\n  EditorSelection,\n  OnCopyFn,\n  OnPasteFn,\n  RangeDecoration,\n  RenderAnnotationFunction,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n  RenderListItemFunction,\n  RenderPlaceholderFunction,\n  RenderStyleFunction,\n  ScrollSelectionIntoViewFunction,\n} from '../types/editor'\nimport type {HotkeyOptions} from '../types/options'\nimport {Element} from './components/Element'\nimport {Leaf} from './components/Leaf'\nimport {EditorActorContext} from './editor-actor-context'\nimport {getEditorSnapshot} from './editor-selector'\nimport {usePortableTextEditor} from './hooks/usePortableTextEditor'\nimport {createWithHotkeys} from './plugins/createWithHotKeys'\nimport {PortableTextEditor} from './PortableTextEditor'\nimport {withSyncRangeDecorations} from './withSyncRangeDecorations'\n\nconst debug = debugWithName('component:Editable')\n\nconst PLACEHOLDER_STYLE: CSSProperties = {\n  position: 'absolute',\n  userSelect: 'none',\n  pointerEvents: 'none',\n  left: 0,\n  right: 0,\n}\n\ninterface BaseRangeWithDecoration extends BaseRange {\n  rangeDecoration: RangeDecoration\n}\n\n/**\n * @public\n */\nexport type PortableTextEditableProps = Omit<\n  TextareaHTMLAttributes<HTMLDivElement>,\n  'onPaste' | 'onCopy' | 'onBeforeInput'\n> & {\n  hotkeys?: HotkeyOptions\n  onBeforeInput?: (event: InputEvent) => void\n  onPaste?: OnPasteFn\n  onCopy?: OnCopyFn\n  ref: MutableRefObject<HTMLDivElement | null>\n  rangeDecorations?: RangeDecoration[]\n  renderAnnotation?: RenderAnnotationFunction\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  renderListItem?: RenderListItemFunction\n  renderPlaceholder?: RenderPlaceholderFunction\n  renderStyle?: RenderStyleFunction\n  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction\n  selection?: EditorSelection\n  spellCheck?: boolean\n}\n\n/**\n * @public\n *\n *\n * The core component that renders the editor. Must be placed within the {@link EditorProvider} component.\n *\n * @example\n * ```tsx\n * import { PortableTextEditable, EditorProvider } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  return (\n *   <EditorProvider>\n *    <PortableTextEditable />\n *  </EditorProvider>\n *  )\n * }\n * ```\n * @group Components\n */\nexport const PortableTextEditable = forwardRef<\n  Omit<HTMLDivElement, 'as' | 'onPaste' | 'onBeforeInput'>,\n  PortableTextEditableProps\n>(function PortableTextEditable(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onCut,\n    onClick,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onDragEnter,\n    onDragOver,\n    onDrop,\n    onDragLeave,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props\n\n  const portableTextEditor = usePortableTextEditor()\n  const ref = useRef<HTMLDivElement | null>(null)\n  const [editableElement, setEditableElement] = useState<HTMLDivElement | null>(\n    null,\n  )\n  const [hasInvalidValue, setHasInvalidValue] = useState(false)\n  const [rangeDecorationState, setRangeDecorationsState] = useState<\n    BaseRangeWithDecoration[]\n  >([])\n\n  // Forward ref to parent component\n  useImperativeHandle<HTMLDivElement | null, HTMLDivElement | null>(\n    forwardedRef,\n    () => ref.current,\n  )\n\n  const rangeDecorationsRef = useRef(rangeDecorations)\n\n  const editorActor = useContext(EditorActorContext)\n  const readOnly = useSelector(editorActor, (s) =>\n    s.matches({'edit mode': 'read only'}),\n  )\n  const schemaTypes = useSelector(editorActor, (s) => s.context.schema)\n  const slateEditor = useSlate()\n\n  const blockTypeName = schemaTypes.block.name\n\n  // Output a minimal React editor inside Editable when in readOnly mode.\n  // NOTE: make sure all the plugins used here can be safely run over again at any point.\n  // There will be a problem if they redefine editor methods and then calling the original method within themselves.\n  useMemo(() => {\n    // React/UI-specific plugins\n    if (readOnly) {\n      debug('Editable is in read only mode')\n      return slateEditor\n    }\n    const withHotKeys = createWithHotkeys(\n      editorActor,\n      portableTextEditor,\n      hotkeys,\n    )\n\n    debug('Editable is in edit mode')\n    return withHotKeys(slateEditor)\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor])\n\n  const renderElement = useCallback(\n    (eProps: RenderElementProps) => (\n      <Element\n        {...eProps}\n        readOnly={readOnly}\n        renderBlock={renderBlock}\n        renderChild={renderChild}\n        renderListItem={renderListItem}\n        renderStyle={renderStyle}\n        schemaTypes={schemaTypes}\n        spellCheck={spellCheck}\n      />\n    ),\n    [\n      schemaTypes,\n      spellCheck,\n      readOnly,\n      renderBlock,\n      renderChild,\n      renderListItem,\n      renderStyle,\n    ],\n  )\n\n  const renderLeaf = useCallback(\n    (\n      lProps: RenderLeafProps & {\n        leaf: Text & {placeholder?: boolean; rangeDecoration?: RangeDecoration}\n      },\n    ) => {\n      if (lProps.leaf._type === 'span') {\n        let rendered = (\n          <Leaf\n            {...lProps}\n            editorActor={editorActor}\n            schemaTypes={schemaTypes}\n            renderAnnotation={renderAnnotation}\n            renderChild={renderChild}\n            renderDecorator={renderDecorator}\n            readOnly={readOnly}\n          />\n        )\n        if (\n          renderPlaceholder &&\n          lProps.leaf.placeholder &&\n          lProps.text.text === ''\n        ) {\n          return (\n            <>\n              <span style={PLACEHOLDER_STYLE} contentEditable={false}>\n                {renderPlaceholder()}\n              </span>\n              {rendered}\n            </>\n          )\n        }\n        const decoration = lProps.leaf.rangeDecoration\n        if (decoration) {\n          rendered = decoration.component({children: rendered})\n        }\n        return rendered\n      }\n      return lProps.children\n    },\n    [\n      editorActor,\n      readOnly,\n      renderAnnotation,\n      renderChild,\n      renderDecorator,\n      renderPlaceholder,\n      schemaTypes,\n    ],\n  )\n\n  const restoreSelectionFromProps = useCallback(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`)\n      const normalizedSelection = normalizeSelection(\n        propsSelection,\n        fromSlateValue(slateEditor.children, blockTypeName),\n      )\n      if (normalizedSelection !== null) {\n        debug(\n          `Normalized selection from props ${JSON.stringify(normalizedSelection)}`,\n        )\n        const slateRange = toSlateRange(normalizedSelection, slateEditor)\n        if (slateRange) {\n          Transforms.select(slateEditor, slateRange)\n          // Output selection here in those cases where the editor selection was the same, and there are no set_selection operations made.\n          // The selection is usually automatically emitted to change$ by the withPortableTextSelections plugin whenever there is a set_selection operation applied.\n          if (!slateEditor.operations.some((o) => o.type === 'set_selection')) {\n            editorActor.send({\n              type: 'notify.selection',\n              selection: normalizedSelection,\n            })\n          }\n          slateEditor.onChange()\n        }\n      }\n    }\n  }, [blockTypeName, editorActor, propsSelection, slateEditor])\n\n  const syncRangeDecorations = useCallback(\n    (operation?: Operation) => {\n      if (rangeDecorations && rangeDecorations.length > 0) {\n        const newSlateRanges: BaseRangeWithDecoration[] = []\n        rangeDecorations.forEach((rangeDecorationItem) => {\n          const slateRange = toSlateRange(\n            rangeDecorationItem.selection,\n            slateEditor,\n          )\n          if (!SlateRange.isRange(slateRange)) {\n            if (rangeDecorationItem.onMoved) {\n              rangeDecorationItem.onMoved({\n                newSelection: null,\n                rangeDecoration: rangeDecorationItem,\n                origin: 'local',\n              })\n            }\n            return\n          }\n          let newRange: BaseRange | null | undefined\n          if (operation) {\n            newRange = moveRangeByOperation(slateRange, operation)\n            if (\n              (newRange && newRange !== slateRange) ||\n              (newRange === null && slateRange)\n            ) {\n              const value = PortableTextEditor.getValue(portableTextEditor)\n              const newRangeSelection = toPortableTextRange(\n                value,\n                newRange,\n                schemaTypes,\n              )\n              if (rangeDecorationItem.onMoved) {\n                rangeDecorationItem.onMoved({\n                  newSelection: newRangeSelection,\n                  rangeDecoration: rangeDecorationItem,\n                  origin: 'local',\n                })\n              }\n            }\n          }\n          // If the newRange is null, it means that the range is not valid anymore and should be removed\n          // If it's undefined, it means that the slateRange is still valid and should be kept\n          if (newRange !== null) {\n            newSlateRanges.push({\n              ...(newRange || slateRange),\n              rangeDecoration: rangeDecorationItem,\n            })\n          }\n        })\n        if (newSlateRanges.length > 0) {\n          setRangeDecorationsState(newSlateRanges)\n          return\n        }\n      }\n      setRangeDecorationsState((rangeDecorationState) => {\n        // If there's state then we want to reset\n        if (rangeDecorationState.length > 0) {\n          return []\n        }\n        // Otherwise we no-op, React will skip a state update if what we return has reference equality to the previous state\n        return rangeDecorationState\n      })\n    },\n    [portableTextEditor, rangeDecorations, schemaTypes, slateEditor],\n  )\n\n  // Restore selection from props when the editor has been initialized properly with it's value\n  useEffect(() => {\n    const onReady = editorActor.on('ready', () => {\n      syncRangeDecorations()\n      restoreSelectionFromProps()\n    })\n    const onInvalidValue = editorActor.on('invalid value', () => {\n      setHasInvalidValue(true)\n    })\n    const onValueChanged = editorActor.on('value changed', () => {\n      setHasInvalidValue(false)\n    })\n\n    return () => {\n      onReady.unsubscribe()\n      onInvalidValue.unsubscribe()\n      onValueChanged.unsubscribe()\n    }\n  }, [editorActor, restoreSelectionFromProps, syncRangeDecorations])\n\n  // Restore selection from props when it changes\n  useEffect(() => {\n    if (propsSelection && !hasInvalidValue) {\n      restoreSelectionFromProps()\n    }\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps])\n\n  const [syncedRangeDecorations, setSyncedRangeDecorations] = useState(false)\n  useEffect(() => {\n    if (!syncedRangeDecorations) {\n      // We only want this to run once, on mount\n      setSyncedRangeDecorations(true)\n      syncRangeDecorations()\n    }\n  }, [syncRangeDecorations, syncedRangeDecorations])\n\n  useEffect(() => {\n    if (!isEqual(rangeDecorations, rangeDecorationsRef.current)) {\n      syncRangeDecorations()\n    }\n    rangeDecorationsRef.current = rangeDecorations\n  }, [rangeDecorations, syncRangeDecorations])\n\n  // Sync range decorations after an operation is applied\n  useEffect(() => {\n    const teardown = withSyncRangeDecorations({\n      editorActor,\n      slateEditor,\n      syncRangeDecorations,\n    })\n    return () => teardown()\n  }, [editorActor, slateEditor, syncRangeDecorations])\n\n  // Handle from props onCopy function\n  const handleCopy = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): void | ReactEditor => {\n      if (onCopy) {\n        const result = onCopy(event)\n        // CopyFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          console.warn('Could not find position for copy event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.copy',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCopy, editorActor, slateEditor],\n  )\n\n  const handleCut = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>) => {\n      if (onCut) {\n        const result = onCut(event)\n        // CutFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          console.warn('Could not find position for cut event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.cut',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCut, editorActor, slateEditor],\n  )\n\n  // Handle incoming pasting events in the editor\n  const handlePaste = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): Promise<void> | void => {\n      const value = PortableTextEditor.getValue(portableTextEditor)\n      const ptRange = toPortableTextRange(\n        value,\n        slateEditor.selection,\n        schemaTypes,\n      )\n      const path = ptRange?.focus.path || []\n      const onPasteResult = onPaste?.({event, value, path, schemaTypes})\n\n      if (onPasteResult || !slateEditor.selection) {\n        event.preventDefault()\n\n        // Resolve it as promise (can be either async promise or sync return value)\n        editorActor.send({type: 'notify.loading'})\n\n        Promise.resolve(onPasteResult)\n          .then((result) => {\n            debug('Custom paste function from client resolved', result)\n\n            if (!result || !result.insert) {\n              debug('No result from custom paste handler, pasting normally')\n\n              const position = getEventPosition({\n                snapshot: getEditorSnapshot({\n                  editorActorSnapshot: editorActor.getSnapshot(),\n                  slateEditorInstance: slateEditor,\n                }),\n                slateEditor,\n                event: event.nativeEvent,\n              })\n\n              if (!position) {\n                console.warn('Could not find position for paste event')\n                return\n              }\n\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'clipboard.paste',\n                  originEvent: {\n                    dataTransfer: event.clipboardData,\n                  },\n                  position,\n                },\n                editor: slateEditor,\n                nativeEvent: event,\n              })\n            } else if (result.insert) {\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'insert.blocks',\n                  blocks: parseBlocks({\n                    context: {\n                      keyGenerator:\n                        editorActor.getSnapshot().context.keyGenerator,\n                      schema: editorActor.getSnapshot().context.schema,\n                    },\n                    blocks: result.insert,\n                    options: {\n                      refreshKeys: true,\n                    },\n                  }),\n                  placement: 'auto',\n                },\n                editor: slateEditor,\n              })\n            } else {\n              console.warn(\n                'Your onPaste function returned something unexpected:',\n                result,\n              )\n            }\n          })\n          .catch((error) => {\n            console.warn(error)\n\n            return error\n          })\n          .finally(() => {\n            editorActor.send({type: 'notify.done loading'})\n          })\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.preventDefault()\n        event.stopPropagation()\n\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          console.warn('Could not find position for paste event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.paste',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n\n      debug('No result from custom paste handler, pasting normally')\n    },\n    [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor],\n  )\n\n  const handleOnFocus: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onFocus) {\n        onFocus(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        const selection = PortableTextEditor.getSelection(portableTextEditor)\n        // Create an editor selection if it does'nt exist\n        if (selection === null) {\n          Transforms.select(slateEditor, Editor.start(slateEditor, []))\n          slateEditor.onChange()\n        }\n        editorActor.send({type: 'notify.focused', event})\n        const newSelection = PortableTextEditor.getSelection(portableTextEditor)\n        // If the selection is the same, emit it explicitly here as there is no actual onChange event triggered.\n        if (selection === newSelection) {\n          editorActor.send({\n            type: 'notify.selection',\n            selection,\n          })\n        }\n      }\n    },\n    [editorActor, onFocus, portableTextEditor, slateEditor],\n  )\n\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n      if (onClick) {\n        onClick(event)\n      }\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        snapshot: getEditorSnapshot({\n          editorActorSnapshot: editorActor.getSnapshot(),\n          slateEditorInstance: slateEditor,\n        }),\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find EventPosition for MouseEvent')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'mouse.click',\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n    },\n    [onClick, editorActor, slateEditor],\n  )\n\n  const handleOnBlur: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onBlur) {\n        onBlur(event)\n      }\n      if (!event.isPropagationStopped()) {\n        editorActor.send({type: 'notify.blurred', event})\n      }\n    },\n    [editorActor, onBlur],\n  )\n\n  const handleOnBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (onBeforeInput) {\n        onBeforeInput(event)\n      }\n    },\n    [onBeforeInput],\n  )\n\n  // This function will handle unexpected DOM changes inside the Editable rendering,\n  // and make sure that we can maintain a stable slateEditor.selection when that happens.\n  //\n  // For example, if this Editable is rendered inside something that might re-render\n  // this component (hidden contexts) while the user is still actively changing the\n  // contentEditable, this could interfere with the intermediate DOM selection,\n  // which again could be picked up by ReactEditor's event listeners.\n  // If that range is invalid at that point, the slate.editorSelection could be\n  // set either wrong, or invalid, to which slateEditor will throw exceptions\n  // that are impossible to recover properly from or result in a wrong selection.\n  //\n  // Also the other way around, when the ReactEditor will try to create a DOM Range\n  // from the current slateEditor.selection, it may throw unrecoverable errors\n  // if the current editor.selection is invalid according to the DOM.\n  // If this is the case, default to selecting the top of the document, if the\n  // user already had a selection.\n  const validateSelection = useCallback(() => {\n    if (!slateEditor.selection) {\n      return\n    }\n    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor)\n    const {activeElement} = root\n    // Return if the editor isn't the active element\n    if (ref.current !== activeElement) {\n      return\n    }\n    const window = ReactEditor.getWindow(slateEditor)\n    const domSelection = window.getSelection()\n    if (!domSelection || domSelection.rangeCount === 0) {\n      return\n    }\n    const existingDOMRange = domSelection.getRangeAt(0)\n    try {\n      const newDOMRange = ReactEditor.toDOMRange(\n        slateEditor,\n        slateEditor.selection,\n      )\n      if (\n        newDOMRange.startOffset !== existingDOMRange.startOffset ||\n        newDOMRange.endOffset !== existingDOMRange.endOffset\n      ) {\n        debug('DOM range out of sync, validating selection')\n        // Remove all ranges temporary\n        domSelection?.removeAllRanges()\n        // Set the correct range\n        domSelection.addRange(newDOMRange)\n      }\n    } catch {\n      debug(`Could not resolve selection, selecting top document`)\n      // Deselect the editor\n      Transforms.deselect(slateEditor)\n      // Select top document if there is a top block to select\n      if (slateEditor.children.length > 0) {\n        Transforms.select(slateEditor, [0, 0])\n      }\n      slateEditor.onChange()\n    }\n  }, [ref, slateEditor])\n\n  // Observe mutations (child list and subtree) to this component's DOM,\n  // and make sure the editor selection is valid when that happens.\n  useEffect(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection)\n      mutationObserver.observe(editableElement, {\n        attributeOldValue: false,\n        attributes: false,\n        characterData: false,\n        childList: true,\n        subtree: true,\n      })\n      return () => {\n        mutationObserver.disconnect()\n      }\n    }\n    return undefined\n  }, [validateSelection, editableElement])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyDown) {\n        props.onKeyDown(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        slateEditor.pteWithHotKeys(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keydown',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const handleKeyUp = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyUp) {\n        props.onKeyUp(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keyup',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const scrollSelectionIntoViewToSlate = useMemo(() => {\n    // Use slate-react default scroll into view\n    if (scrollSelectionIntoView === undefined) {\n      return undefined\n    }\n    // Disable scroll into view totally\n    if (scrollSelectionIntoView === null) {\n      return noop\n    }\n    // Translate PortableTextEditor prop fn to Slate plugin fn\n    return (_editor: ReactEditor, domRange: Range) => {\n      scrollSelectionIntoView(portableTextEditor, domRange)\n    }\n  }, [portableTextEditor, scrollSelectionIntoView])\n\n  const decorate: (entry: NodeEntry) => BaseRange[] = useCallback(\n    ([, path]) => {\n      if (isEqualToEmptyEditor(slateEditor.children, schemaTypes)) {\n        return [\n          {\n            anchor: {\n              path: [0, 0],\n              offset: 0,\n            },\n            focus: {\n              path: [0, 0],\n              offset: 0,\n            },\n            placeholder: true,\n          },\n        ]\n      }\n      // Editor node has a path length of 0 (should never be decorated)\n      if (path.length === 0) {\n        return []\n      }\n      const result = rangeDecorationState.filter((item) => {\n        // Special case in order to only return one decoration for collapsed ranges\n        if (SlateRange.isCollapsed(item)) {\n          // Collapsed ranges should only be decorated if they are on a block child level (length 2)\n          if (path.length !== 2) {\n            return false\n          }\n          return (\n            Path.equals(item.focus.path, path) &&\n            Path.equals(item.anchor.path, path)\n          )\n        }\n        // Include decorations that either include or intersects with this path\n        return (\n          SlateRange.intersection(item, {\n            anchor: {path, offset: 0},\n            focus: {path, offset: 0},\n          }) || SlateRange.includes(item, path)\n        )\n      })\n      if (result.length > 0) {\n        return result\n      }\n      return []\n    },\n    [slateEditor, schemaTypes, rangeDecorationState],\n  )\n\n  // Set the forwarded ref to be the Slate editable DOM element\n  // Also set the editable element in a state so that the MutationObserver\n  // is setup when this element is ready.\n  useEffect(() => {\n    ref.current = ReactEditor.toDOMNode(\n      slateEditor,\n      slateEditor,\n    ) as HTMLDivElement | null\n    setEditableElement(ref.current)\n  }, [slateEditor, ref])\n\n  useEffect(() => {\n    const window = ReactEditor.getWindow(slateEditor)\n\n    const onDragEnd = () => {\n      editorActor.send({type: 'dragend'})\n    }\n    const onDrop = () => {\n      editorActor.send({type: 'drop'})\n    }\n\n    window.document.addEventListener('dragend', onDragEnd)\n    window.document.addEventListener('drop', onDrop)\n\n    return () => {\n      window.document.removeEventListener('dragend', onDragEnd)\n      window.document.removeEventListener('drop', onDrop)\n    }\n  }, [slateEditor, editorActor])\n\n  const handleDragStart = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragStart?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          console.warn('Could not find position for dragstart event')\n          return\n        }\n\n        if (ReactEditor.hasTarget(slateEditor, event.target)) {\n          const node = ReactEditor.toSlateNode(slateEditor, event.target)\n          const path = ReactEditor.findPath(slateEditor, node)\n          const voidMatch =\n            (SlateElement.isElement(node) &&\n              Editor.isVoid(slateEditor, node)) ||\n            Editor.void(slateEditor, {at: path, voids: true})\n\n          // If starting a drag on a void node, make sure it is selected\n          // so that it shows up in the selection's fragment.\n          if (voidMatch) {\n            const range = Editor.range(slateEditor, path)\n            Transforms.select(slateEditor, range)\n          }\n        }\n\n        editorActor.send({\n          type: 'dragstart',\n          origin: position,\n        })\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.dragstart',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n            position,\n          },\n          editor: slateEditor,\n        })\n\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n      }\n    },\n    [onDragStart, editorActor, slateEditor],\n  )\n\n  const handleDrag = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrag?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.drag',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n          },\n          editor: slateEditor,\n        })\n\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n      }\n    },\n    [onDrag, editorActor, slateEditor],\n  )\n\n  const handleDragEnd = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnd?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.dragend',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n          },\n          editor: slateEditor,\n        })\n\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n      }\n    },\n    [onDragEnd, editorActor, slateEditor],\n  )\n\n  const handleDragEnter = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnter?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.dragenter',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n            position,\n          },\n          editor: slateEditor,\n        })\n\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n      }\n    },\n    [onDragEnter, editorActor, slateEditor],\n  )\n\n  const handleDragOver = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragOver?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.dragover',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n      }\n    },\n    [onDragOver, editorActor, slateEditor],\n  )\n\n  const handleDrop = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrop?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          console.warn('Could not find position for drop event')\n          return\n        }\n\n        // Find and select the range where the drop happened\n        const range = ReactEditor.findEventRange(slateEditor, event)\n        slateEditor.select(range)\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.drop',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n            position,\n          },\n          editor: slateEditor,\n        })\n\n        // Prevent Slate from handling the event\n        event.preventDefault()\n      }\n    },\n    [onDrop, editorActor, slateEditor],\n  )\n\n  const handleDragLeave = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragLeave?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.dragleave',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n          },\n          editor: slateEditor,\n        })\n      }\n    },\n    [onDragLeave, editorActor, slateEditor],\n  )\n\n  if (!portableTextEditor) {\n    return null\n  }\n\n  return hasInvalidValue ? null : (\n    <SlateEditable\n      {...restProps}\n      autoFocus={false}\n      className={restProps.className || 'pt-editable'}\n      decorate={decorate}\n      onBlur={handleOnBlur}\n      onCopy={handleCopy}\n      onCut={handleCut}\n      onClick={handleClick}\n      onDOMBeforeInput={handleOnBeforeInput}\n      onDragStart={handleDragStart}\n      onDrag={handleDrag}\n      onDragEnd={handleDragEnd}\n      onDragEnter={handleDragEnter}\n      onDragOver={handleDragOver}\n      onDrop={handleDrop}\n      onDragLeave={handleDragLeave}\n      onFocus={handleOnFocus}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      onPaste={handlePaste}\n      readOnly={readOnly}\n      // We have implemented our own placeholder logic with decorations.\n      // This 'renderPlaceholder' should not be used.\n      renderPlaceholder={undefined}\n      renderElement={renderElement}\n      renderLeaf={renderLeaf}\n      scrollSelectionIntoView={scrollSelectionIntoViewToSlate}\n    />\n  )\n})\n\nPortableTextEditable.displayName = 'ForwardRef(PortableTextEditable)'\n","import {useEffect} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {EditorEmittedEvent} from './editor/editor-machine'\nimport {useEditor} from './editor/editor-provider'\n\n/**\n * @public\n * @deprecated\n * This component has been renamed. Use `EventListenerPlugin` instead.\n *\n * ```\n * import {EventListenerPlugin} from '@portabletext/editor/plugins'\n * ```\n */\nexport function EditorEventListener(props: {\n  on: (event: EditorEmittedEvent) => void\n}) {\n  const editor = useEditor()\n  const on = useEffectEvent(props.on)\n\n  useEffect(() => {\n    const subscription = editor.on('*', on)\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [editor])\n\n  return null\n}\n"],"names":["getEventPosition","snapshot","slateEditor","event","DOMEditor","hasTarget","target","node","toSlateNode","isClipboardEvent","selection","context","block","isEditor","Editor","getEventPositionBlock","getEventPositionSelection","ReactEditor","elementRect","toDOMNode","getBoundingClientRect","top","height","Math","abs","pageY","range","getSlateRangeFromEvent","toPortableTextRange","value","schema","collapsedSelection","selectors","focusTextBlock","focusSpan","type","blockStartPoint","utils","blockEndPoint","anchor","focus","editor","isDOMNode","window","getWindow","domRange","document","caretPositionFromPoint","undefined","position","clientX","clientY","createRange","setStart","offsetNode","offset","setEnd","caretRangeFromPoint","console","warn","toSlateRange","exactMatch","suppressThrow","normalizePoint","point","newPath","newOffset","blockKey","path","_key","childKey","find","blk","push","children","Array","isArray","length","child","cld","text","normalizeSelection","newAnchor","newFocus","isEqual","backward","DefaultBlockObject","props","$","_c","t0","Symbol","for","userSelect","t1","_type","jsxs","DefaultInlineObject","DropIndicator","width","borderBottom","zIndex","useDraggable","editorActor","useContext","EditorActorContext","useSlateStatic","blockElement","setBlockElement","useState","blockRef","element","current","useEffect","t2","send","handleDragEnd","t3","getEditorSnapshot","editorActorSnapshot","getSnapshot","slateEditorInstance","nativeEvent","error","HTMLElement","dragGhost","cloneNode","customGhost","querySelector","setAttribute","body","style","left","boxSizing","appendChild","rect","x","y","dataTransfer","setDragImage","origin","ghost","handleDragStart","readOnly","t4","draggableProps","draggable","onDragStart","onDragEnd","debugWithName","EMPTY_ANNOTATIONS","inlineBlockStyle","display","Element","attributes","schemaTypes","renderBlock","renderChild","renderListItem","renderStyle","spellCheck","selected","useSelected","useRef","inlineBlockObjectRef","focused","Range","isCollapsed","dragPositionBlock","setDragPositionBlock","behavior","defineBehavior","on","guard","dropFocusBlock","dragOrigin","beta","internalDrag","some","draggedBlock","actions","effect","useMemo","fromSlateValue","name","KEY_TO_VALUE_ELEMENT","get","renderedBlock","className","blockPath","Error","isInline","findPath","depth","schemaType","inlineObjects","SlateElement","isElement","elmPath","debugRenders","annotations","jsx","editorElementRef","isListItem","blockStyleType","styles","item","level","listItem","isListBlock","listType","lists","renderProps","Object","defineProperty","enumerable","propsOrDefaultRendered","blockObjects","renderedBlockFromProps","_props","displayName","debug","EMPTY_MARKS","Leaf","leaf","renderDecorator","renderAnnotation","spanRef","portableTextEditor","usePortableTextEditor","blockSelected","setFocused","setSelected","parent","decoratorValues","decorators","map","dec","marks","uniq","filter","mark","includes","annotationMarks","markDefs","def","Boolean","shouldTrackSelectionAndFocus","sel","PortableTextEditor","getSelection","isCollapsedSelection","startTransition","setSelectedFromRange","useCallback","winSelection","rangeCount","getRangeAt","intersectsNode","onBlur","onFocus","onSelection","unsubscribe","content","returnedChildren","Text","isText","span","forEach","annotation","t","_child","createWithHotkeys","hotkeysFromOptions","reservedHotkeys","activeHotkeys","pteWithHotKeys","keys","cat","hotkey","isHotkey","preventDefault","possibleMark","behaviorEvent","decorator","possibleCommand","command","withSyncRangeDecorations","syncRangeDecorations","originalApply","apply","op","matches","PLACEHOLDER_STYLE","pointerEvents","right","PortableTextEditable","forwardRef","forwardedRef","hotkeys","onBeforeInput","onPaste","onCopy","onCut","onClick","onDrag","onDragEnter","onDragOver","onDrop","onDragLeave","rangeDecorations","renderPlaceholder","propsSelection","scrollSelectionIntoView","restProps","ref","editableElement","setEditableElement","hasInvalidValue","setHasInvalidValue","rangeDecorationState","setRangeDecorationsState","rangeDecorationsRef","useSelector","s","useSlate","blockTypeName","withHotKeys","renderElement","eProps","renderLeaf","lProps","rendered","placeholder","Fragment","decoration","rangeDecoration","component","restoreSelectionFromProps","JSON","stringify","normalizedSelection","slateRange","Transforms","select","operations","o","onChange","operation","newSlateRanges","rangeDecorationItem","SlateRange","isRange","onMoved","newSelection","newRange","moveRangeByOperation","getValue","newRangeSelection","onReady","onInvalidValue","onValueChanged","syncedRangeDecorations","setSyncedRangeDecorations","teardown","handleCopy","clipboardData","stopPropagation","originEvent","handleCut","handlePaste","onPasteResult","Promise","resolve","then","result","insert","blocks","parseBlocks","keyGenerator","options","refreshKeys","placement","catch","finally","handleOnFocus","isDefaultPrevented","start","handleClick","isPropagationStopped","handleOnBlur","handleOnBeforeInput","validateSelection","root","findDocumentOrShadowRoot","activeElement","domSelection","existingDOMRange","newDOMRange","toDOMRange","startOffset","endOffset","removeAllRanges","addRange","deselect","mutationObserver","MutationObserver","observe","attributeOldValue","characterData","childList","subtree","disconnect","handleKeyDown","onKeyDown","key","code","altKey","ctrlKey","metaKey","shiftKey","handleKeyUp","onKeyUp","scrollSelectionIntoViewToSlate","noop","_editor","decorate","isEqualToEmptyEditor","Path","equals","intersection","addEventListener","removeEventListener","isVoid","void","at","voids","handleDrag","handleDragEnter","handleDragOver","handleDrop","findEventRange","handleDragLeave","SlateEditable","EditorEventListener","useEditor","useEffectEvent","subscription"],"mappings":"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"}