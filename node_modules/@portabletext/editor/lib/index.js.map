{"version":3,"file":"index.js","sources":["../src/internal-utils/event-position.ts","../src/internal-utils/selection.ts","../src/editor/components/DefaultObject.tsx","../src/editor/components/drop-indicator.tsx","../src/editor/components/use-draggable.ts","../src/editor/components/Element.tsx","../src/editor/components/Leaf.tsx","../src/editor/plugins/createWithHotKeys.ts","../src/editor/withSyncRangeDecorations.ts","../src/editor/Editable.tsx","../src/editor-event-listener.tsx"],"sourcesContent":["import {Editor, type BaseRange} from 'slate'\nimport {DOMEditor, isDOMNode} from 'slate-dom'\nimport {ReactEditor} from 'slate-react'\nimport type {EditorSelection, EditorSnapshot} from '..'\nimport * as selectors from '../selectors'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport * as utils from '../utils'\nimport {toPortableTextRange} from './ranges'\n\nexport type EventPosition = {\n  block: 'start' | 'end'\n  /**\n   * Did the event origin from the editor DOM node itself or from a child node?\n   */\n  isEditor: boolean\n  selection: NonNullable<EditorSelection>\n}\nexport type EventPositionBlock = EventPosition['block']\n\nexport function getEventPosition({\n  snapshot,\n  slateEditor,\n  event,\n}: {\n  snapshot: EditorSnapshot\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | ClipboardEvent | MouseEvent\n}): EventPosition | undefined {\n  if (!DOMEditor.hasTarget(slateEditor, event.target)) {\n    return undefined\n  }\n\n  const node = DOMEditor.toSlateNode(slateEditor, event.target)\n\n  if (isClipboardEvent(event)) {\n    const selection = snapshot.context.selection\n\n    if (!selection) {\n      return undefined\n    }\n\n    return {\n      block: 'end',\n      isEditor: Editor.isEditor(node),\n      selection,\n    }\n  }\n\n  const block = getEventPositionBlock({slateEditor, event})\n  const selection = getEventPositionSelection({snapshot, slateEditor, event})\n\n  if (!block || !selection) {\n    return undefined\n  }\n\n  return {\n    block,\n    isEditor: Editor.isEditor(node),\n    selection,\n  }\n}\n\nfunction getEventPositionBlock({\n  slateEditor,\n  event,\n}: {\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPositionBlock | undefined {\n  if (!ReactEditor.hasTarget(slateEditor, event.target)) {\n    return undefined\n  }\n\n  const node = ReactEditor.toSlateNode(slateEditor, event.target)\n  const element = ReactEditor.toDOMNode(slateEditor, node)\n  const elementRect = element.getBoundingClientRect()\n  const top = elementRect.top\n  const height = elementRect.height\n  const location = Math.abs(top - event.pageY)\n\n  return location < height / 2 ? 'start' : 'end'\n}\n\nfunction getEventPositionSelection({\n  snapshot,\n  slateEditor,\n  event,\n}: {\n  snapshot: EditorSnapshot\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EditorSelection {\n  const range = getSlateRangeFromEvent(slateEditor, event)\n\n  const selection = range\n    ? toPortableTextRange(\n        snapshot.context.value,\n        range,\n        snapshot.context.schema,\n      )\n    : null\n\n  if (!selection) {\n    return selection\n  }\n\n  const collapsedSelection = selectors.isSelectionCollapsed({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const focusTextBlock = selectors.getFocusTextBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const focusSpan = selectors.getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n\n  if (\n    event.type === 'dragstart' &&\n    collapsedSelection &&\n    focusTextBlock &&\n    focusSpan\n  ) {\n    // Looks like we are dragging an empty span. Let's drag the entire block\n    // instead\n\n    const blockStartPoint = utils.getBlockStartPoint(focusTextBlock)\n    const blockEndPoint = utils.getBlockEndPoint(focusTextBlock)\n\n    return {\n      anchor: blockStartPoint,\n      focus: blockEndPoint,\n    }\n  }\n\n  return selection\n}\n\nfunction getSlateRangeFromEvent(\n  editor: PortableTextSlateEditor,\n  event: DragEvent | MouseEvent,\n) {\n  if (!event.target) {\n    return undefined\n  }\n\n  if (!isDOMNode(event.target)) {\n    return undefined\n  }\n\n  const window = DOMEditor.getWindow(editor)\n\n  let domRange: Range | undefined\n\n  if (window.document.caretPositionFromPoint !== undefined) {\n    const position = window.document.caretPositionFromPoint(\n      event.clientX,\n      event.clientY,\n    )\n\n    if (position) {\n      domRange = window.document.createRange()\n      domRange.setStart(position.offsetNode, position.offset)\n      domRange.setEnd(position.offsetNode, position.offset)\n    }\n  } else if (window.document.caretRangeFromPoint !== undefined) {\n    // Use WebKit-proprietary fallback method\n    domRange =\n      window.document.caretRangeFromPoint(event.clientX, event.clientY) ??\n      undefined\n  } else {\n    console.warn(\n      'Neither caretPositionFromPoint nor caretRangeFromPoint is supported',\n    )\n    return undefined\n  }\n\n  if (!domRange) {\n    return undefined\n  }\n\n  let range: BaseRange | undefined\n\n  try {\n    range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      // It can still throw even with this option set to true\n      suppressThrow: false,\n    })\n  } catch {}\n\n  return range\n}\n\nfunction isClipboardEvent(\n  event: DragEvent | ClipboardEvent | MouseEvent,\n): event is ClipboardEvent {\n  return event.type === 'copy' || event.type === 'cut' || event.type === 'paste'\n}\n","import type {Path, PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\nexport function normalizePoint(\n  point: EditorSelectionPoint,\n  value: PortableTextBlock[],\n): EditorSelectionPoint | null {\n  if (!point || !value) {\n    return null\n  }\n  const newPath: Path = []\n  let newOffset: number = point.offset || 0\n  const blockKey =\n    typeof point.path[0] === 'object' &&\n    '_key' in point.path[0] &&\n    point.path[0]._key\n  const childKey =\n    typeof point.path[2] === 'object' &&\n    '_key' in point.path[2] &&\n    point.path[2]._key\n  const block: PortableTextBlock | undefined = value.find(\n    (blk) => blk._key === blockKey,\n  )\n  if (block) {\n    newPath.push({_key: block._key})\n  } else {\n    return null\n  }\n  if (block && point.path[1] === 'children') {\n    if (\n      !block.children ||\n      (Array.isArray(block.children) && block.children.length === 0)\n    ) {\n      return null\n    }\n    const child =\n      Array.isArray(block.children) &&\n      block.children.find((cld) => cld._key === childKey)\n    if (child) {\n      newPath.push('children')\n      newPath.push({_key: child._key})\n      newOffset =\n        child.text && child.text.length >= point.offset\n          ? point.offset\n          : (child.text && child.text.length) || 0\n    } else {\n      return null\n    }\n  }\n  return {path: newPath, offset: newOffset}\n}\n\nexport function normalizeSelection(\n  selection: EditorSelection,\n  value: PortableTextBlock[] | undefined,\n): EditorSelection | null {\n  if (!selection || !value || value.length === 0) {\n    return null\n  }\n  let newAnchor: EditorSelectionPoint | null = null\n  let newFocus: EditorSelectionPoint | null = null\n  const {anchor, focus} = selection\n  if (\n    anchor &&\n    value.find((blk) => isEqual({_key: blk._key}, anchor.path[0]))\n  ) {\n    newAnchor = normalizePoint(anchor, value)\n  }\n  if (focus && value.find((blk) => isEqual({_key: blk._key}, focus.path[0]))) {\n    newFocus = normalizePoint(focus, value)\n  }\n  if (newAnchor && newFocus) {\n    return {anchor: newAnchor, focus: newFocus, backward: selection.backward}\n  }\n  return null\n}\n","import type {PortableTextBlock, PortableTextChild} from '@sanity/types'\n\nexport function DefaultBlockObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <div style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </div>\n  )\n}\n\nexport function DefaultInlineObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <span style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </span>\n  )\n}\n","export function DropIndicator() {\n  return (\n    <div\n      className=\"pt-drop-indicator\"\n      style={{\n        position: 'absolute',\n        width: '100%',\n        height: 1,\n        borderBottom: '1px solid currentColor',\n        zIndex: 5,\n      }}\n    />\n  )\n}\n","import {\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n  type DragEvent,\n  type RefObject,\n} from 'react'\nimport type {Element as SlateElement} from 'slate'\nimport {ReactEditor, useSlateStatic} from 'slate-react'\nimport {getEventPosition} from '../../internal-utils/event-position'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {getEditorSnapshot} from '../editor-selector'\n\ntype Draggable = {\n  draggableProps: {\n    draggable: boolean\n    onDragStart?: (event: DragEvent) => void\n    onDragEnd?: (event: DragEvent) => void\n  }\n}\n\nexport function useDraggable(props: {\n  element: SlateElement\n  readOnly: boolean\n  blockRef: RefObject<HTMLDivElement | null>\n}): Draggable {\n  const editorActor = useContext(EditorActorContext)\n  const editor = useSlateStatic()\n  const [blockElement, setBlockElement] = useState<HTMLElement | null>(null)\n\n  useEffect(\n    () =>\n      setBlockElement(\n        props.blockRef\n          ? props.blockRef.current\n          : ReactEditor.toDOMNode(editor, props.element),\n      ),\n    [editor, props.element, props.blockRef],\n  )\n\n  const handleDragEnd = useCallback(() => {\n    editorActor.send({type: 'dragend'})\n  }, [editorActor])\n\n  const handleDragStart = useCallback(\n    (event: DragEvent) => {\n      const position = getEventPosition({\n        snapshot: getEditorSnapshot({\n          editorActorSnapshot: editorActor.getSnapshot(),\n          slateEditorInstance: editor,\n        }),\n        slateEditor: editor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.error('Could not find position for dragstart event')\n        return\n      }\n\n      // Clone blockElement so that it will not be visually clipped by scroll-containers etc.\n      // The application that uses the portable-text-editor may indicate the element used as\n      // drag ghost by adding a truthy data attribute 'data-pt-drag-ghost-element' to a HTML element.\n      if (blockElement && blockElement instanceof HTMLElement) {\n        let dragGhost = blockElement.cloneNode(true) as HTMLElement\n        const customGhost = dragGhost.querySelector(\n          '[data-pt-drag-ghost-element]',\n        )\n        if (customGhost) {\n          dragGhost = customGhost as HTMLElement\n        }\n\n        // Set the `data-dragged` attribute so the consumer can style the element while itâ€™s dragged\n        dragGhost.setAttribute('data-dragged', '')\n\n        if (document.body) {\n          dragGhost.style.position = 'absolute'\n          dragGhost.style.left = '-99999px'\n          dragGhost.style.boxSizing = 'border-box'\n          document.body.appendChild(dragGhost)\n          const rect = blockElement.getBoundingClientRect()\n          const x = event.clientX - rect.left\n          const y = event.clientY - rect.top\n          dragGhost.style.width = `${rect.width}px`\n          dragGhost.style.height = `${rect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n\n          editorActor.send({\n            type: 'dragstart',\n            origin: position,\n            ghost: dragGhost,\n          })\n          return\n        }\n\n        editorActor.send({\n          type: 'dragstart',\n          origin: position,\n        })\n      }\n    },\n    [blockElement, editor, editorActor],\n  )\n\n  if (props.readOnly) {\n    return {\n      draggableProps: {\n        draggable: false,\n        onDragStart: undefined,\n        onDragEnd: undefined,\n      },\n    }\n  }\n\n  return {\n    draggableProps: {\n      draggable: true,\n      onDragStart: handleDragStart,\n      onDragEnd: handleDragEnd,\n    },\n  }\n}\n","import type {\n  Path,\n  PortableTextChild,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type FunctionComponent,\n  type JSX,\n  type ReactElement,\n} from 'react'\nimport {Editor, Range, Element as SlateElement} from 'slate'\nimport {\n  ReactEditor,\n  useSelected,\n  useSlateStatic,\n  type RenderElementProps,\n} from 'slate-react'\nimport {defineBehavior} from '../../behaviors'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport {fromSlateValue} from '../../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../../internal-utils/weakMaps'\nimport * as selectors from '../../selectors'\nimport type {\n  BlockRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {DefaultBlockObject, DefaultInlineObject} from './DefaultObject'\nimport {DropIndicator} from './drop-indicator'\nimport {useDraggable} from './use-draggable'\n\nconst debug = debugWithName('components:Element')\nconst debugRenders = false\nconst EMPTY_ANNOTATIONS: PortableTextObject[] = []\n\n/**\n * @internal\n */\nexport interface ElementProps {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement<any>\n  element: SlateElement\n  schemaTypes: PortableTextMemberSchemaTypes\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n}\n\nconst inlineBlockStyle = {display: 'inline-block'}\n\n/**\n * Renders Portable Text block and inline object nodes in Slate\n * @internal\n */\nexport const Element: FunctionComponent<ElementProps> = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck,\n}) => {\n  const editorActor = useContext(EditorActorContext)\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n  const blockRef = useRef<HTMLDivElement | null>(null)\n  const inlineBlockObjectRef = useRef(null)\n  const focused =\n    (selected &&\n      slateEditor.selection &&\n      Range.isCollapsed(slateEditor.selection)) ||\n    false\n  const [dragPositionBlock, setDragPositionBlock] =\n    useState<EventPositionBlock>()\n  const draggable = useDraggable({element, readOnly, blockRef})\n\n  useEffect(() => {\n    const behavior = defineBehavior({\n      on: 'drag.dragover',\n      guard: ({snapshot, event}) => {\n        const dropFocusBlock = selectors.getFocusBlock({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: event.position.selection,\n          },\n        })\n\n        if (!dropFocusBlock || dropFocusBlock.node._key !== element._key) {\n          return false\n        }\n\n        const dragOrigin = snapshot.beta.internalDrag?.origin\n\n        if (!dragOrigin) {\n          return false\n        }\n\n        const draggedBlocks = selectors.getSelectedBlocks({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection,\n          },\n        })\n\n        if (\n          draggedBlocks.some(\n            (draggedBlock) => draggedBlock.node._key === element._key,\n          )\n        ) {\n          return false\n        }\n\n        const draggingEntireBlocks = selectors.isSelectingEntireBlocks({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection,\n          },\n        })\n\n        return draggingEntireBlocks\n      },\n      actions: [\n        ({event}) => [\n          {\n            type: 'effect',\n            effect: () => {\n              setDragPositionBlock(event.position.block)\n            },\n          },\n          {\n            type: 'noop',\n          },\n        ],\n      ],\n    })\n\n    editorActor.send({\n      type: 'add behavior',\n      behavior,\n    })\n\n    return () => {\n      editorActor.send({\n        type: 'remove behavior',\n        behavior,\n      })\n    }\n  }, [editorActor, element._key])\n\n  useEffect(() => {\n    const behavior = defineBehavior({\n      on: 'drag.*',\n      guard: ({event}) => {\n        return event.type !== 'drag.dragover'\n      },\n      actions: [\n        () => [\n          {\n            type: 'effect',\n            effect: () => {\n              setDragPositionBlock(undefined)\n            },\n          },\n        ],\n      ],\n    })\n\n    editorActor.send({\n      type: 'add behavior',\n      behavior,\n    })\n\n    return () => {\n      editorActor.send({\n        type: 'remove behavior',\n        behavior,\n      })\n    }\n  }, [editorActor])\n\n  const value = useMemo(\n    () =>\n      fromSlateValue(\n        [element],\n        schemaTypes.block.name,\n        KEY_TO_VALUE_ELEMENT.get(slateEditor),\n      )[0],\n    [slateEditor, element, schemaTypes.block.name],\n  )\n\n  let renderedBlock = children\n\n  let className: string | undefined\n\n  const blockPath: Path = useMemo(() => [{_key: element._key}], [element])\n\n  if (typeof element._type !== 'string') {\n    throw new Error(`Expected element to have a _type property`)\n  }\n\n  if (typeof element._key !== 'string') {\n    throw new Error(`Expected element to have a _key property`)\n  }\n\n  // Test for inline objects first\n  if (slateEditor.isInline(element)) {\n    const path = ReactEditor.findPath(slateEditor, element)\n    const [block] = Editor.node(slateEditor, path, {depth: 1})\n    const schemaType = schemaTypes.inlineObjects.find(\n      (_type) => _type.name === element._type,\n    )\n    if (!schemaType) {\n      throw new Error('Could not find type for inline block element')\n    }\n    if (SlateElement.isElement(block)) {\n      const elmPath: Path = [\n        {_key: block._key},\n        'children',\n        {_key: element._key},\n      ]\n      if (debugRenders) {\n        debug(`Render ${element._key} (inline object)`)\n      }\n      return (\n        <span {...attributes}>\n          {/* Note that children must follow immediately or cut and selections will not work properly in Chrome. */}\n          {children}\n          <span\n            draggable={!readOnly}\n            className=\"pt-inline-object\"\n            data-testid=\"pt-inline-object\"\n            ref={inlineBlockObjectRef}\n            key={element._key}\n            style={inlineBlockStyle}\n            contentEditable={false}\n          >\n            {renderChild &&\n              renderChild({\n                annotations: EMPTY_ANNOTATIONS, // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n                children: <DefaultInlineObject value={value} />,\n                editorElementRef: inlineBlockObjectRef,\n                focused,\n                path: elmPath,\n                schemaType,\n                selected,\n                type: schemaType,\n                value: value as PortableTextChild,\n              })}\n            {!renderChild && <DefaultInlineObject value={value} />}\n          </span>\n        </span>\n      )\n    }\n    throw new Error('Block not found!')\n  }\n\n  // If not inline, it's either a block (text) or a block object (non-text)\n  // NOTE: text blocks aren't draggable with DraggableBlock (yet?)\n  if (element._type === schemaTypes.block.name) {\n    className = `pt-block pt-text-block`\n    const isListItem = 'listItem' in element\n    if (debugRenders) {\n      debug(`Render ${element._key} (text block)`)\n    }\n    const style = ('style' in element && element.style) || 'normal'\n    className = `pt-block pt-text-block pt-text-block-style-${style}`\n    const blockStyleType = schemaTypes.styles.find(\n      (item) => item.value === style,\n    )\n    if (renderStyle && blockStyleType) {\n      renderedBlock = renderStyle({\n        block: element as PortableTextTextBlock,\n        children,\n        focused,\n        selected,\n        value: style,\n        path: blockPath,\n        schemaType: blockStyleType,\n        editorElementRef: blockRef,\n      })\n    }\n    let level: number | undefined\n\n    if (isListItem) {\n      if (typeof element.level === 'number') {\n        level = element.level\n      }\n      className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`\n    }\n\n    if (slateEditor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find(\n        (item) => item.value === element.listItem,\n      )\n      if (renderListItem && listType) {\n        renderedBlock = renderListItem({\n          block: value,\n          children: renderedBlock,\n          focused,\n          selected,\n          value: element.listItem,\n          path: blockPath,\n          schemaType: listType,\n          level: value.level || 1,\n          editorElementRef: blockRef,\n        })\n      }\n    }\n\n    const renderProps: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: renderedBlock,\n        editorElementRef: blockRef,\n        focused,\n        level,\n        listItem: isListItem ? element.listItem : undefined,\n        path: blockPath,\n        selected,\n        style,\n        schemaType: schemaTypes.block,\n        value,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaTypes.block\n        },\n      },\n    )\n\n    const propsOrDefaultRendered = renderBlock\n      ? renderBlock(renderProps as BlockRenderProps)\n      : children\n\n    return (\n      <div\n        key={element._key}\n        {...attributes}\n        className={className}\n        spellCheck={spellCheck}\n      >\n        {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n        <div ref={blockRef}>{propsOrDefaultRendered}</div>\n        {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n      </div>\n    )\n  }\n\n  const schemaType = schemaTypes.blockObjects.find(\n    (_type) => _type.name === element._type,\n  )\n\n  if (!schemaType) {\n    throw new Error(\n      `Could not find schema type for block element of _type ${element._type}`,\n    )\n  }\n\n  if (debugRenders) {\n    debug(`Render ${element._key} (object block)`)\n  }\n\n  className = 'pt-block pt-object-block'\n\n  const block = fromSlateValue(\n    [element],\n    schemaTypes.block.name,\n    KEY_TO_VALUE_ELEMENT.get(slateEditor),\n  )[0]\n\n  let renderedBlockFromProps: JSX.Element | undefined\n\n  if (renderBlock) {\n    const _props: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: <DefaultBlockObject value={value} />,\n        editorElementRef: blockRef,\n        focused,\n        path: blockPath,\n        schemaType,\n        selected,\n        value: block,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaType\n        },\n      },\n    )\n    renderedBlockFromProps = renderBlock(_props as BlockRenderProps)\n  }\n\n  return (\n    <div\n      key={element._key}\n      {...attributes}\n      className={className}\n      {...draggable.draggableProps}\n    >\n      {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n      {children}\n      <div ref={blockRef} contentEditable={false}>\n        {renderedBlockFromProps ? (\n          renderedBlockFromProps\n        ) : (\n          <DefaultBlockObject value={value} />\n        )}\n      </div>\n      {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n    </div>\n  )\n}\n\nElement.displayName = 'Element'\n","import type {\n  Path,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ReactElement,\n} from 'react'\nimport {Text} from 'slate'\nimport {useSelected, type RenderLeafProps} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {\n  BlockAnnotationRenderProps,\n  BlockChildRenderProps,\n  BlockDecoratorRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderAnnotationFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {usePortableTextEditor} from '../hooks/usePortableTextEditor'\nimport {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('components:Leaf')\n\nconst EMPTY_MARKS: string[] = []\n\n/**\n * @internal\n */\nexport interface LeafProps extends RenderLeafProps {\n  editorActor: EditorActor\n  children: ReactElement<any>\n  schemaTypes: PortableTextMemberSchemaTypes\n  renderAnnotation?: RenderAnnotationFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  readOnly: boolean\n}\n\n/**\n * Renders Portable Text span nodes in Slate\n * @internal\n */\nexport const Leaf = (props: LeafProps) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation,\n  } = props\n  const spanRef = useRef<HTMLElement>(null)\n  const portableTextEditor = usePortableTextEditor()\n  const blockSelected = useSelected()\n  const [focused, setFocused] = useState(false)\n  const [selected, setSelected] = useState(false)\n  const block = children.props.parent as PortableTextTextBlock | undefined\n  const path: Path = useMemo(\n    () => (block ? [{_key: block?._key}, 'children', {_key: leaf._key}] : []),\n    [block, leaf._key],\n  )\n  const decoratorValues = useMemo(\n    () => schemaTypes.decorators.map((dec) => dec.value),\n    [schemaTypes.decorators],\n  )\n  const marks: string[] = useMemo(\n    () =>\n      uniq(\n        (leaf.marks || EMPTY_MARKS).filter((mark) =>\n          decoratorValues.includes(mark),\n        ),\n      ),\n    [decoratorValues, leaf.marks],\n  )\n  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS\n  const annotations = useMemo(\n    () =>\n      annotationMarks\n        .map(\n          (mark) =>\n            !decoratorValues.includes(mark) &&\n            block?.markDefs?.find((def) => def._key === mark),\n        )\n        .filter(Boolean) as PortableTextObject[],\n    [annotationMarks, block, decoratorValues],\n  )\n\n  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(false)\n      return\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor)\n    if (\n      sel &&\n      isEqual(sel.focus.path, path) &&\n      PortableTextEditor.isCollapsedSelection(portableTextEditor)\n    ) {\n      startTransition(() => {\n        setFocused(true)\n      })\n    }\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor])\n\n  // Function to check if this leaf is currently inside the user's text selection\n  const setSelectedFromRange = useCallback(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return\n    }\n    debug('Setting selection and focus from range')\n    const winSelection = window.getSelection()\n    if (!winSelection) {\n      setSelected(false)\n      return\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0)\n      if (spanRef.current && range.intersectsNode(spanRef.current)) {\n        setSelected(true)\n      } else {\n        setSelected(false)\n      }\n    } else {\n      setSelected(false)\n    }\n  }, [shouldTrackSelectionAndFocus])\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return undefined\n    }\n\n    const onBlur = editorActor.on('blur', () => {\n      setFocused(false)\n      setSelected(false)\n    })\n\n    const onFocus = editorActor.on('focus', () => {\n      const sel = PortableTextEditor.getSelection(portableTextEditor)\n      if (\n        sel &&\n        isEqual(sel.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      }\n      setSelectedFromRange()\n    })\n\n    const onSelection = editorActor.on('selection', (event) => {\n      if (\n        event.selection &&\n        isEqual(event.selection.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      } else {\n        setFocused(false)\n      }\n      setSelectedFromRange()\n    })\n\n    return () => {\n      onBlur.unsubscribe()\n      onFocus.unsubscribe()\n      onSelection.unsubscribe()\n    }\n  }, [\n    editorActor,\n    path,\n    portableTextEditor,\n    setSelectedFromRange,\n    shouldTrackSelectionAndFocus,\n  ])\n\n  useEffect(() => setSelectedFromRange(), [setSelectedFromRange])\n\n  const content = useMemo(() => {\n    let returnedChildren = children\n    // Render text nodes\n    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name) {\n      marks.forEach((mark) => {\n        const schemaType = schemaTypes.decorators.find(\n          (dec) => dec.value === mark,\n        )\n        if (schemaType && renderDecorator) {\n          const _props: Omit<BlockDecoratorRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                children: returnedChildren,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                selected,\n                schemaType,\n                value: mark,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaType\n                },\n              },\n            )\n          returnedChildren = renderDecorator(\n            _props as BlockDecoratorRenderProps,\n          )\n        }\n      })\n\n      if (block && annotations.length > 0) {\n        annotations.forEach((annotation) => {\n          const schemaType = schemaTypes.annotations.find(\n            (t) => t.name === annotation._type,\n          )\n          if (schemaType) {\n            if (renderAnnotation) {\n              const _props: Omit<BlockAnnotationRenderProps, 'type'> =\n                Object.defineProperty(\n                  {\n                    block,\n                    children: returnedChildren,\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    selected,\n                    schemaType,\n                    value: annotation,\n                  },\n                  'type',\n                  {\n                    enumerable: false,\n                    get() {\n                      console.warn(\n                        \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                      )\n                      return schemaType\n                    },\n                  },\n                )\n\n              returnedChildren = (\n                <span ref={spanRef}>\n                  {renderAnnotation(_props as BlockAnnotationRenderProps)}\n                </span>\n              )\n            } else {\n              returnedChildren = <span ref={spanRef}>{returnedChildren}</span>\n            }\n          }\n        })\n      }\n      if (block && renderChild) {\n        const child = block.children.find((_child) => _child._key === leaf._key) // Ensure object equality\n        if (child) {\n          const defaultRendered = <>{returnedChildren}</>\n          const _props: Omit<BlockChildRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                annotations,\n                children: defaultRendered,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                schemaType: schemaTypes.span,\n                selected,\n                value: child,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaTypes.span\n                },\n              },\n            )\n          returnedChildren = renderChild(_props as BlockChildRenderProps)\n        }\n      }\n    }\n    return returnedChildren\n  }, [\n    annotations,\n    block,\n    children,\n    focused,\n    leaf,\n    marks,\n    path,\n    renderAnnotation,\n    renderChild,\n    renderDecorator,\n    schemaTypes.annotations,\n    schemaTypes.decorators,\n    schemaTypes.span,\n    selected,\n  ])\n  return useMemo(\n    () => (\n      <span key={leaf._key} {...attributes} ref={spanRef}>\n        {content}\n      </span>\n    ),\n    [leaf, attributes, content],\n  )\n}\n\nLeaf.displayName = 'Leaf'\n","import type {KeyboardEvent} from 'react'\nimport type {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isHotkey} from '../../internal-utils/is-hotkey'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {HotkeyOptions} from '../../types/options'\nimport type {EditorActor} from '../editor-machine'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('plugin:withHotKeys')\n\n/**\n * This plugin takes care of all hotkeys in the editor\n *\n */\nexport function createWithHotkeys(\n  editorActor: EditorActor,\n  portableTextEditor: PortableTextEditor,\n  hotkeysFromOptions?: HotkeyOptions,\n): (editor: PortableTextSlateEditor & ReactEditor) => any {\n  const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end']\n  const activeHotkeys = hotkeysFromOptions ?? {}\n  return function withHotKeys(editor: PortableTextSlateEditor & ReactEditor) {\n    editor.pteWithHotKeys = (event: KeyboardEvent<HTMLDivElement>): void => {\n      // Wire up custom marks hotkeys\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === 'marks') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault()\n              const possibleMark = activeHotkeys[cat]\n              if (possibleMark) {\n                const mark = possibleMark[hotkey]\n                debug(`HotKey ${hotkey} to toggle ${mark}`)\n                editorActor.send({\n                  type: 'behavior event',\n                  behaviorEvent: {\n                    type: 'decorator.toggle',\n                    decorator: mark,\n                  },\n                  editor,\n                })\n              }\n            }\n          }\n        }\n        if (cat === 'custom') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat]\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey]\n                command(event, portableTextEditor)\n              }\n            }\n          }\n        }\n      })\n    }\n    return editor\n  }\n}\n","import type {BaseEditor, Operation} from 'slate'\nimport type {ReactEditor} from 'slate-react'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorActor} from './editor-machine'\n\n// React Compiler considers `slateEditor` as immutable, and opts-out if we do this inline in a useEffect, doing it in a function moves it out of the scope, and opts-in again for the rest of the component.\nexport function withSyncRangeDecorations({\n  editorActor,\n  slateEditor,\n  syncRangeDecorations,\n}: {\n  editorActor: EditorActor\n  slateEditor: BaseEditor & ReactEditor & PortableTextSlateEditor\n  syncRangeDecorations: (operation?: Operation) => void\n}) {\n  const originalApply = slateEditor.apply\n\n  slateEditor.apply = (op: Operation) => {\n    originalApply(op)\n\n    if (\n      !editorActor.getSnapshot().matches({'edit mode': 'read only'}) &&\n      op.type !== 'set_selection'\n    ) {\n      syncRangeDecorations(op)\n    }\n  }\n\n  return () => {\n    slateEditor.apply = originalApply\n  }\n}\n","import {useSelector} from '@xstate/react'\nimport {isEqual, noop} from 'lodash'\nimport {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n  type ClipboardEvent,\n  type CSSProperties,\n  type FocusEventHandler,\n  type KeyboardEvent,\n  type MutableRefObject,\n  type TextareaHTMLAttributes,\n} from 'react'\nimport {\n  Editor,\n  Path,\n  Element as SlateElement,\n  Range as SlateRange,\n  Transforms,\n  type BaseRange,\n  type NodeEntry,\n  type Operation,\n  type Text,\n} from 'slate'\nimport {\n  ReactEditor,\n  Editable as SlateEditable,\n  useSlate,\n  type RenderElementProps,\n  type RenderLeafProps,\n} from 'slate-react'\nimport {debugWithName} from '../internal-utils/debug'\nimport {getEventPosition} from '../internal-utils/event-position'\nimport {parseBlocks} from '../internal-utils/parse-blocks'\nimport {\n  moveRangeByOperation,\n  toPortableTextRange,\n  toSlateRange,\n} from '../internal-utils/ranges'\nimport {normalizeSelection} from '../internal-utils/selection'\nimport {fromSlateValue, isEqualToEmptyEditor} from '../internal-utils/values'\nimport type {\n  EditorSelection,\n  OnCopyFn,\n  OnPasteFn,\n  RangeDecoration,\n  RenderAnnotationFunction,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n  RenderListItemFunction,\n  RenderPlaceholderFunction,\n  RenderStyleFunction,\n  ScrollSelectionIntoViewFunction,\n} from '../types/editor'\nimport type {HotkeyOptions} from '../types/options'\nimport {Element} from './components/Element'\nimport {Leaf} from './components/Leaf'\nimport {EditorActorContext} from './editor-actor-context'\nimport {getEditorSnapshot} from './editor-selector'\nimport {usePortableTextEditor} from './hooks/usePortableTextEditor'\nimport {createWithHotkeys} from './plugins/createWithHotKeys'\nimport {PortableTextEditor} from './PortableTextEditor'\nimport {withSyncRangeDecorations} from './withSyncRangeDecorations'\n\nconst debug = debugWithName('component:Editable')\n\nconst PLACEHOLDER_STYLE: CSSProperties = {\n  position: 'absolute',\n  userSelect: 'none',\n  pointerEvents: 'none',\n  left: 0,\n  right: 0,\n}\n\ninterface BaseRangeWithDecoration extends BaseRange {\n  rangeDecoration: RangeDecoration\n}\n\n/**\n * @public\n */\nexport type PortableTextEditableProps = Omit<\n  TextareaHTMLAttributes<HTMLDivElement>,\n  'onPaste' | 'onCopy' | 'onBeforeInput'\n> & {\n  hotkeys?: HotkeyOptions\n  onBeforeInput?: (event: InputEvent) => void\n  onPaste?: OnPasteFn\n  onCopy?: OnCopyFn\n  ref: MutableRefObject<HTMLDivElement | null>\n  rangeDecorations?: RangeDecoration[]\n  renderAnnotation?: RenderAnnotationFunction\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  renderListItem?: RenderListItemFunction\n  renderPlaceholder?: RenderPlaceholderFunction\n  renderStyle?: RenderStyleFunction\n  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction\n  selection?: EditorSelection\n  spellCheck?: boolean\n}\n\n/**\n * @public\n *\n *\n * The core component that renders the editor. Must be placed within the {@link EditorProvider} component.\n *\n * @example\n * ```tsx\n * import { PortableTextEditable, EditorProvider } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  return (\n *   <EditorProvider>\n *    <PortableTextEditable />\n *  </EditorProvider>\n *  )\n * }\n * ```\n * @group Components\n */\nexport const PortableTextEditable = forwardRef<\n  Omit<HTMLDivElement, 'as' | 'onPaste' | 'onBeforeInput'>,\n  PortableTextEditableProps\n>(function PortableTextEditable(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onCut,\n    onClick,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onDragEnter,\n    onDragOver,\n    onDrop,\n    onDragLeave,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props\n\n  const portableTextEditor = usePortableTextEditor()\n  const ref = useRef<HTMLDivElement | null>(null)\n  const [editableElement, setEditableElement] = useState<HTMLDivElement | null>(\n    null,\n  )\n  const [hasInvalidValue, setHasInvalidValue] = useState(false)\n  const [rangeDecorationState, setRangeDecorationsState] = useState<\n    BaseRangeWithDecoration[]\n  >([])\n\n  // Forward ref to parent component\n  useImperativeHandle<HTMLDivElement | null, HTMLDivElement | null>(\n    forwardedRef,\n    () => ref.current,\n  )\n\n  const rangeDecorationsRef = useRef(rangeDecorations)\n\n  const editorActor = useContext(EditorActorContext)\n  const readOnly = useSelector(editorActor, (s) =>\n    s.matches({'edit mode': 'read only'}),\n  )\n  const schemaTypes = useSelector(editorActor, (s) => s.context.schema)\n  const slateEditor = useSlate()\n\n  const blockTypeName = schemaTypes.block.name\n\n  // Output a minimal React editor inside Editable when in readOnly mode.\n  // NOTE: make sure all the plugins used here can be safely run over again at any point.\n  // There will be a problem if they redefine editor methods and then calling the original method within themselves.\n  useMemo(() => {\n    // React/UI-specific plugins\n    if (readOnly) {\n      debug('Editable is in read only mode')\n      return slateEditor\n    }\n    const withHotKeys = createWithHotkeys(\n      editorActor,\n      portableTextEditor,\n      hotkeys,\n    )\n\n    debug('Editable is in edit mode')\n    return withHotKeys(slateEditor)\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor])\n\n  const renderElement = useCallback(\n    (eProps: RenderElementProps) => (\n      <Element\n        {...eProps}\n        readOnly={readOnly}\n        renderBlock={renderBlock}\n        renderChild={renderChild}\n        renderListItem={renderListItem}\n        renderStyle={renderStyle}\n        schemaTypes={schemaTypes}\n        spellCheck={spellCheck}\n      />\n    ),\n    [\n      schemaTypes,\n      spellCheck,\n      readOnly,\n      renderBlock,\n      renderChild,\n      renderListItem,\n      renderStyle,\n    ],\n  )\n\n  const renderLeaf = useCallback(\n    (\n      lProps: RenderLeafProps & {\n        leaf: Text & {placeholder?: boolean; rangeDecoration?: RangeDecoration}\n      },\n    ) => {\n      if (lProps.leaf._type === 'span') {\n        let rendered = (\n          <Leaf\n            {...lProps}\n            editorActor={editorActor}\n            schemaTypes={schemaTypes}\n            renderAnnotation={renderAnnotation}\n            renderChild={renderChild}\n            renderDecorator={renderDecorator}\n            readOnly={readOnly}\n          />\n        )\n        if (\n          renderPlaceholder &&\n          lProps.leaf.placeholder &&\n          lProps.text.text === ''\n        ) {\n          return (\n            <>\n              <span style={PLACEHOLDER_STYLE} contentEditable={false}>\n                {renderPlaceholder()}\n              </span>\n              {rendered}\n            </>\n          )\n        }\n        const decoration = lProps.leaf.rangeDecoration\n        if (decoration) {\n          rendered = decoration.component({children: rendered})\n        }\n        return rendered\n      }\n      return lProps.children\n    },\n    [\n      editorActor,\n      readOnly,\n      renderAnnotation,\n      renderChild,\n      renderDecorator,\n      renderPlaceholder,\n      schemaTypes,\n    ],\n  )\n\n  const restoreSelectionFromProps = useCallback(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`)\n      const normalizedSelection = normalizeSelection(\n        propsSelection,\n        fromSlateValue(slateEditor.children, blockTypeName),\n      )\n      if (normalizedSelection !== null) {\n        debug(\n          `Normalized selection from props ${JSON.stringify(normalizedSelection)}`,\n        )\n        const slateRange = toSlateRange(normalizedSelection, slateEditor)\n        if (slateRange) {\n          Transforms.select(slateEditor, slateRange)\n          // Output selection here in those cases where the editor selection was the same, and there are no set_selection operations made.\n          // The selection is usually automatically emitted to change$ by the withPortableTextSelections plugin whenever there is a set_selection operation applied.\n          if (!slateEditor.operations.some((o) => o.type === 'set_selection')) {\n            editorActor.send({\n              type: 'notify.selection',\n              selection: normalizedSelection,\n            })\n          }\n          slateEditor.onChange()\n        }\n      }\n    }\n  }, [blockTypeName, editorActor, propsSelection, slateEditor])\n\n  const syncRangeDecorations = useCallback(\n    (operation?: Operation) => {\n      if (rangeDecorations && rangeDecorations.length > 0) {\n        const newSlateRanges: BaseRangeWithDecoration[] = []\n        rangeDecorations.forEach((rangeDecorationItem) => {\n          const slateRange = toSlateRange(\n            rangeDecorationItem.selection,\n            slateEditor,\n          )\n          if (!SlateRange.isRange(slateRange)) {\n            if (rangeDecorationItem.onMoved) {\n              rangeDecorationItem.onMoved({\n                newSelection: null,\n                rangeDecoration: rangeDecorationItem,\n                origin: 'local',\n              })\n            }\n            return\n          }\n          let newRange: BaseRange | null | undefined\n          if (operation) {\n            newRange = moveRangeByOperation(slateRange, operation)\n            if (\n              (newRange && newRange !== slateRange) ||\n              (newRange === null && slateRange)\n            ) {\n              const value = PortableTextEditor.getValue(portableTextEditor)\n              const newRangeSelection = toPortableTextRange(\n                value,\n                newRange,\n                schemaTypes,\n              )\n              if (rangeDecorationItem.onMoved) {\n                rangeDecorationItem.onMoved({\n                  newSelection: newRangeSelection,\n                  rangeDecoration: rangeDecorationItem,\n                  origin: 'local',\n                })\n              }\n            }\n          }\n          // If the newRange is null, it means that the range is not valid anymore and should be removed\n          // If it's undefined, it means that the slateRange is still valid and should be kept\n          if (newRange !== null) {\n            newSlateRanges.push({\n              ...(newRange || slateRange),\n              rangeDecoration: rangeDecorationItem,\n            })\n          }\n        })\n        if (newSlateRanges.length > 0) {\n          setRangeDecorationsState(newSlateRanges)\n          return\n        }\n      }\n      setRangeDecorationsState((rangeDecorationState) => {\n        // If there's state then we want to reset\n        if (rangeDecorationState.length > 0) {\n          return []\n        }\n        // Otherwise we no-op, React will skip a state update if what we return has reference equality to the previous state\n        return rangeDecorationState\n      })\n    },\n    [portableTextEditor, rangeDecorations, schemaTypes, slateEditor],\n  )\n\n  // Restore selection from props when the editor has been initialized properly with it's value\n  useEffect(() => {\n    const onReady = editorActor.on('ready', () => {\n      syncRangeDecorations()\n      restoreSelectionFromProps()\n    })\n    const onInvalidValue = editorActor.on('invalid value', () => {\n      setHasInvalidValue(true)\n    })\n    const onValueChanged = editorActor.on('value changed', () => {\n      setHasInvalidValue(false)\n    })\n\n    return () => {\n      onReady.unsubscribe()\n      onInvalidValue.unsubscribe()\n      onValueChanged.unsubscribe()\n    }\n  }, [editorActor, restoreSelectionFromProps, syncRangeDecorations])\n\n  // Restore selection from props when it changes\n  useEffect(() => {\n    if (propsSelection && !hasInvalidValue) {\n      restoreSelectionFromProps()\n    }\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps])\n\n  const [syncedRangeDecorations, setSyncedRangeDecorations] = useState(false)\n  useEffect(() => {\n    if (!syncedRangeDecorations) {\n      // We only want this to run once, on mount\n      setSyncedRangeDecorations(true)\n      syncRangeDecorations()\n    }\n  }, [syncRangeDecorations, syncedRangeDecorations])\n\n  useEffect(() => {\n    if (!isEqual(rangeDecorations, rangeDecorationsRef.current)) {\n      syncRangeDecorations()\n    }\n    rangeDecorationsRef.current = rangeDecorations\n  }, [rangeDecorations, syncRangeDecorations])\n\n  // Sync range decorations after an operation is applied\n  useEffect(() => {\n    const teardown = withSyncRangeDecorations({\n      editorActor,\n      slateEditor,\n      syncRangeDecorations,\n    })\n    return () => teardown()\n  }, [editorActor, slateEditor, syncRangeDecorations])\n\n  // Handle from props onCopy function\n  const handleCopy = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): void | ReactEditor => {\n      if (onCopy) {\n        const result = onCopy(event)\n        // CopyFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          console.warn('Could not find position for copy event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.copy',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCopy, editorActor, slateEditor],\n  )\n\n  const handleCut = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>) => {\n      if (onCut) {\n        const result = onCut(event)\n        // CutFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          console.warn('Could not find position for cut event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.cut',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCut, editorActor, slateEditor],\n  )\n\n  // Handle incoming pasting events in the editor\n  const handlePaste = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): Promise<void> | void => {\n      const value = PortableTextEditor.getValue(portableTextEditor)\n      const ptRange = toPortableTextRange(\n        value,\n        slateEditor.selection,\n        schemaTypes,\n      )\n      const path = ptRange?.focus.path || []\n      const onPasteResult = onPaste?.({event, value, path, schemaTypes})\n\n      if (onPasteResult || !slateEditor.selection) {\n        event.preventDefault()\n\n        // Resolve it as promise (can be either async promise or sync return value)\n        editorActor.send({type: 'notify.loading'})\n\n        Promise.resolve(onPasteResult)\n          .then((result) => {\n            debug('Custom paste function from client resolved', result)\n\n            if (!result || !result.insert) {\n              debug('No result from custom paste handler, pasting normally')\n\n              const position = getEventPosition({\n                snapshot: getEditorSnapshot({\n                  editorActorSnapshot: editorActor.getSnapshot(),\n                  slateEditorInstance: slateEditor,\n                }),\n                slateEditor,\n                event: event.nativeEvent,\n              })\n\n              if (!position) {\n                console.warn('Could not find position for paste event')\n                return\n              }\n\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'clipboard.paste',\n                  originEvent: {\n                    dataTransfer: event.clipboardData,\n                  },\n                  position,\n                },\n                editor: slateEditor,\n                nativeEvent: event,\n              })\n            } else if (result.insert) {\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'insert.blocks',\n                  blocks: parseBlocks({\n                    context: {\n                      keyGenerator:\n                        editorActor.getSnapshot().context.keyGenerator,\n                      schema: editorActor.getSnapshot().context.schema,\n                    },\n                    blocks: result.insert,\n                    options: {\n                      refreshKeys: true,\n                    },\n                  }),\n                  placement: 'auto',\n                },\n                editor: slateEditor,\n              })\n            } else {\n              console.warn(\n                'Your onPaste function returned something unexpected:',\n                result,\n              )\n            }\n          })\n          .catch((error) => {\n            console.warn(error)\n\n            return error\n          })\n          .finally(() => {\n            editorActor.send({type: 'notify.done loading'})\n          })\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.preventDefault()\n        event.stopPropagation()\n\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          console.warn('Could not find position for paste event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.paste',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n\n      debug('No result from custom paste handler, pasting normally')\n    },\n    [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor],\n  )\n\n  const handleOnFocus: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onFocus) {\n        onFocus(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        const selection = PortableTextEditor.getSelection(portableTextEditor)\n        // Create an editor selection if it does'nt exist\n        if (selection === null) {\n          Transforms.select(slateEditor, Editor.start(slateEditor, []))\n          slateEditor.onChange()\n        }\n        editorActor.send({type: 'notify.focused', event})\n        const newSelection = PortableTextEditor.getSelection(portableTextEditor)\n        // If the selection is the same, emit it explicitly here as there is no actual onChange event triggered.\n        if (selection === newSelection) {\n          editorActor.send({\n            type: 'notify.selection',\n            selection,\n          })\n        }\n      }\n    },\n    [editorActor, onFocus, portableTextEditor, slateEditor],\n  )\n\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n      if (onClick) {\n        onClick(event)\n      }\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        snapshot: getEditorSnapshot({\n          editorActorSnapshot: editorActor.getSnapshot(),\n          slateEditorInstance: slateEditor,\n        }),\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find EventPosition for MouseEvent')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'mouse.click',\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n    },\n    [onClick, editorActor, slateEditor],\n  )\n\n  const handleOnBlur: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onBlur) {\n        onBlur(event)\n      }\n      if (!event.isPropagationStopped()) {\n        editorActor.send({type: 'notify.blurred', event})\n      }\n    },\n    [editorActor, onBlur],\n  )\n\n  const handleOnBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (onBeforeInput) {\n        onBeforeInput(event)\n      }\n    },\n    [onBeforeInput],\n  )\n\n  // This function will handle unexpected DOM changes inside the Editable rendering,\n  // and make sure that we can maintain a stable slateEditor.selection when that happens.\n  //\n  // For example, if this Editable is rendered inside something that might re-render\n  // this component (hidden contexts) while the user is still actively changing the\n  // contentEditable, this could interfere with the intermediate DOM selection,\n  // which again could be picked up by ReactEditor's event listeners.\n  // If that range is invalid at that point, the slate.editorSelection could be\n  // set either wrong, or invalid, to which slateEditor will throw exceptions\n  // that are impossible to recover properly from or result in a wrong selection.\n  //\n  // Also the other way around, when the ReactEditor will try to create a DOM Range\n  // from the current slateEditor.selection, it may throw unrecoverable errors\n  // if the current editor.selection is invalid according to the DOM.\n  // If this is the case, default to selecting the top of the document, if the\n  // user already had a selection.\n  const validateSelection = useCallback(() => {\n    if (!slateEditor.selection) {\n      return\n    }\n    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor)\n    const {activeElement} = root\n    // Return if the editor isn't the active element\n    if (ref.current !== activeElement) {\n      return\n    }\n    const window = ReactEditor.getWindow(slateEditor)\n    const domSelection = window.getSelection()\n    if (!domSelection || domSelection.rangeCount === 0) {\n      return\n    }\n    const existingDOMRange = domSelection.getRangeAt(0)\n    try {\n      const newDOMRange = ReactEditor.toDOMRange(\n        slateEditor,\n        slateEditor.selection,\n      )\n      if (\n        newDOMRange.startOffset !== existingDOMRange.startOffset ||\n        newDOMRange.endOffset !== existingDOMRange.endOffset\n      ) {\n        debug('DOM range out of sync, validating selection')\n        // Remove all ranges temporary\n        domSelection?.removeAllRanges()\n        // Set the correct range\n        domSelection.addRange(newDOMRange)\n      }\n    } catch {\n      debug(`Could not resolve selection, selecting top document`)\n      // Deselect the editor\n      Transforms.deselect(slateEditor)\n      // Select top document if there is a top block to select\n      if (slateEditor.children.length > 0) {\n        Transforms.select(slateEditor, [0, 0])\n      }\n      slateEditor.onChange()\n    }\n  }, [ref, slateEditor])\n\n  // Observe mutations (child list and subtree) to this component's DOM,\n  // and make sure the editor selection is valid when that happens.\n  useEffect(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection)\n      mutationObserver.observe(editableElement, {\n        attributeOldValue: false,\n        attributes: false,\n        characterData: false,\n        childList: true,\n        subtree: true,\n      })\n      return () => {\n        mutationObserver.disconnect()\n      }\n    }\n    return undefined\n  }, [validateSelection, editableElement])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyDown) {\n        props.onKeyDown(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        slateEditor.pteWithHotKeys(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keydown',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const handleKeyUp = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyUp) {\n        props.onKeyUp(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keyup',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const scrollSelectionIntoViewToSlate = useMemo(() => {\n    // Use slate-react default scroll into view\n    if (scrollSelectionIntoView === undefined) {\n      return undefined\n    }\n    // Disable scroll into view totally\n    if (scrollSelectionIntoView === null) {\n      return noop\n    }\n    // Translate PortableTextEditor prop fn to Slate plugin fn\n    return (_editor: ReactEditor, domRange: Range) => {\n      scrollSelectionIntoView(portableTextEditor, domRange)\n    }\n  }, [portableTextEditor, scrollSelectionIntoView])\n\n  const decorate: (entry: NodeEntry) => BaseRange[] = useCallback(\n    ([, path]) => {\n      if (isEqualToEmptyEditor(slateEditor.children, schemaTypes)) {\n        return [\n          {\n            anchor: {\n              path: [0, 0],\n              offset: 0,\n            },\n            focus: {\n              path: [0, 0],\n              offset: 0,\n            },\n            placeholder: true,\n          },\n        ]\n      }\n      // Editor node has a path length of 0 (should never be decorated)\n      if (path.length === 0) {\n        return []\n      }\n      const result = rangeDecorationState.filter((item) => {\n        // Special case in order to only return one decoration for collapsed ranges\n        if (SlateRange.isCollapsed(item)) {\n          // Collapsed ranges should only be decorated if they are on a block child level (length 2)\n          if (path.length !== 2) {\n            return false\n          }\n          return (\n            Path.equals(item.focus.path, path) &&\n            Path.equals(item.anchor.path, path)\n          )\n        }\n        // Include decorations that either include or intersects with this path\n        return (\n          SlateRange.intersection(item, {\n            anchor: {path, offset: 0},\n            focus: {path, offset: 0},\n          }) || SlateRange.includes(item, path)\n        )\n      })\n      if (result.length > 0) {\n        return result\n      }\n      return []\n    },\n    [slateEditor, schemaTypes, rangeDecorationState],\n  )\n\n  // Set the forwarded ref to be the Slate editable DOM element\n  // Also set the editable element in a state so that the MutationObserver\n  // is setup when this element is ready.\n  useEffect(() => {\n    ref.current = ReactEditor.toDOMNode(\n      slateEditor,\n      slateEditor,\n    ) as HTMLDivElement | null\n    setEditableElement(ref.current)\n  }, [slateEditor, ref])\n\n  useEffect(() => {\n    const window = ReactEditor.getWindow(slateEditor)\n\n    const onDragEnd = () => {\n      editorActor.send({type: 'dragend'})\n    }\n    const onDrop = () => {\n      editorActor.send({type: 'drop'})\n    }\n\n    window.document.addEventListener('dragend', onDragEnd)\n    window.document.addEventListener('drop', onDrop)\n\n    return () => {\n      window.document.removeEventListener('dragend', onDragEnd)\n      window.document.removeEventListener('drop', onDrop)\n    }\n  }, [slateEditor, editorActor])\n\n  const handleDragStart = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragStart?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          console.warn('Could not find position for dragstart event')\n          return\n        }\n\n        if (ReactEditor.hasTarget(slateEditor, event.target)) {\n          const node = ReactEditor.toSlateNode(slateEditor, event.target)\n          const path = ReactEditor.findPath(slateEditor, node)\n          const voidMatch =\n            (SlateElement.isElement(node) &&\n              Editor.isVoid(slateEditor, node)) ||\n            Editor.void(slateEditor, {at: path, voids: true})\n\n          // If starting a drag on a void node, make sure it is selected\n          // so that it shows up in the selection's fragment.\n          if (voidMatch) {\n            const range = Editor.range(slateEditor, path)\n            Transforms.select(slateEditor, range)\n          }\n        }\n\n        editorActor.send({\n          type: 'dragstart',\n          origin: position,\n        })\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.dragstart',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n            position,\n          },\n          editor: slateEditor,\n        })\n\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n      }\n    },\n    [onDragStart, editorActor, slateEditor],\n  )\n\n  const handleDrag = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrag?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.drag',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n          },\n          editor: slateEditor,\n        })\n\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n      }\n    },\n    [onDrag, editorActor, slateEditor],\n  )\n\n  const handleDragEnd = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnd?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.dragend',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n          },\n          editor: slateEditor,\n        })\n\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n      }\n    },\n    [onDragEnd, editorActor, slateEditor],\n  )\n\n  const handleDragEnter = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnter?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.dragenter',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n            position,\n          },\n          editor: slateEditor,\n        })\n\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n      }\n    },\n    [onDragEnter, editorActor, slateEditor],\n  )\n\n  const handleDragOver = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragOver?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.dragover',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n      }\n    },\n    [onDragOver, editorActor, slateEditor],\n  )\n\n  const handleDrop = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrop?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        const position = getEventPosition({\n          snapshot: getEditorSnapshot({\n            editorActorSnapshot: editorActor.getSnapshot(),\n            slateEditorInstance: slateEditor,\n          }),\n          slateEditor,\n          event: event.nativeEvent,\n        })\n\n        if (!position) {\n          console.warn('Could not find position for drop event')\n          return\n        }\n\n        // Find and select the range where the drop happened\n        const range = ReactEditor.findEventRange(slateEditor, event)\n        slateEditor.select(range)\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.drop',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n            position,\n          },\n          editor: slateEditor,\n        })\n\n        // Prevent Slate from handling the event\n        event.preventDefault()\n      }\n    },\n    [onDrop, editorActor, slateEditor],\n  )\n\n  const handleDragLeave = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragLeave?.(event)\n\n      if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'drag.dragleave',\n            originEvent: {\n              dataTransfer: event.dataTransfer,\n            },\n          },\n          editor: slateEditor,\n        })\n      }\n    },\n    [onDragLeave, editorActor, slateEditor],\n  )\n\n  if (!portableTextEditor) {\n    return null\n  }\n\n  return hasInvalidValue ? null : (\n    <SlateEditable\n      {...restProps}\n      autoFocus={false}\n      className={restProps.className || 'pt-editable'}\n      decorate={decorate}\n      onBlur={handleOnBlur}\n      onCopy={handleCopy}\n      onCut={handleCut}\n      onClick={handleClick}\n      onDOMBeforeInput={handleOnBeforeInput}\n      onDragStart={handleDragStart}\n      onDrag={handleDrag}\n      onDragEnd={handleDragEnd}\n      onDragEnter={handleDragEnter}\n      onDragOver={handleDragOver}\n      onDrop={handleDrop}\n      onDragLeave={handleDragLeave}\n      onFocus={handleOnFocus}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      onPaste={handlePaste}\n      readOnly={readOnly}\n      // We have implemented our own placeholder logic with decorations.\n      // This 'renderPlaceholder' should not be used.\n      renderPlaceholder={undefined}\n      renderElement={renderElement}\n      renderLeaf={renderLeaf}\n      scrollSelectionIntoView={scrollSelectionIntoViewToSlate}\n    />\n  )\n})\n\nPortableTextEditable.displayName = 'ForwardRef(PortableTextEditable)'\n","import {useEffect} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {EditorEmittedEvent} from './editor/editor-machine'\nimport {useEditor} from './editor/editor-provider'\n\n/**\n * @public\n * @deprecated\n * This component has been renamed. Use `EventListenerPlugin` instead.\n *\n * ```\n * import {EventListenerPlugin} from '@portabletext/editor/plugins'\n * ```\n */\nexport function EditorEventListener(props: {\n  on: (event: EditorEmittedEvent) => void\n}) {\n  const editor = useEditor()\n  const on = useEffectEvent(props.on)\n\n  useEffect(() => {\n    const subscription = editor.on('*', on)\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [editor])\n\n  return null\n}\n"],"names":["getEventPosition","snapshot","slateEditor","event","DOMEditor","hasTarget","target","node","toSlateNode","isClipboardEvent","selection","context","block","isEditor","Editor","getEventPositionBlock","getEventPositionSelection","ReactEditor","elementRect","toDOMNode","getBoundingClientRect","top","height","Math","abs","pageY","range","getSlateRangeFromEvent","toPortableTextRange","value","schema","collapsedSelection","selectors","focusTextBlock","focusSpan","type","blockStartPoint","utils","blockEndPoint","anchor","focus","editor","isDOMNode","window","getWindow","domRange","document","caretPositionFromPoint","undefined","position","clientX","clientY","createRange","setStart","offsetNode","offset","setEnd","caretRangeFromPoint","console","warn","toSlateRange","exactMatch","suppressThrow","normalizePoint","point","newPath","newOffset","blockKey","path","_key","childKey","find","blk","push","children","Array","isArray","length","child","cld","text","normalizeSelection","newAnchor","newFocus","isEqual","backward","DefaultBlockObject","props","$","_c","t0","Symbol","for","userSelect","t1","_type","DefaultInlineObject","DropIndicator","width","borderBottom","zIndex","useDraggable","editorActor","useContext","EditorActorContext","useSlateStatic","blockElement","setBlockElement","useState","blockRef","element","current","useEffect","t2","send","handleDragEnd","t3","getEditorSnapshot","editorActorSnapshot","getSnapshot","slateEditorInstance","nativeEvent","error","HTMLElement","dragGhost","cloneNode","customGhost","querySelector","setAttribute","body","style","left","boxSizing","appendChild","rect","x","y","dataTransfer","setDragImage","origin","ghost","handleDragStart","readOnly","t4","draggableProps","draggable","onDragStart","onDragEnd","debugWithName","EMPTY_ANNOTATIONS","inlineBlockStyle","display","Element","attributes","schemaTypes","renderBlock","renderChild","renderListItem","renderStyle","spellCheck","selected","useSelected","useRef","inlineBlockObjectRef","focused","Range","isCollapsed","dragPositionBlock","setDragPositionBlock","behavior","defineBehavior","on","guard","dropFocusBlock","dragOrigin","beta","internalDrag","some","draggedBlock","actions","effect","useMemo","fromSlateValue","name","KEY_TO_VALUE_ELEMENT","get","renderedBlock","className","blockPath","Error","isInline","findPath","depth","schemaType","inlineObjects","SlateElement","isElement","elmPath","debugRenders","annotations","editorElementRef","isListItem","blockStyleType","styles","item","level","listItem","isListBlock","listType","lists","renderProps","Object","defineProperty","enumerable","propsOrDefaultRendered","blockObjects","renderedBlockFromProps","_props","displayName","debug","EMPTY_MARKS","Leaf","leaf","renderDecorator","renderAnnotation","spanRef","portableTextEditor","usePortableTextEditor","blockSelected","setFocused","setSelected","parent","decoratorValues","decorators","map","dec","marks","uniq","filter","mark","includes","annotationMarks","markDefs","def","Boolean","shouldTrackSelectionAndFocus","sel","PortableTextEditor","getSelection","isCollapsedSelection","startTransition","setSelectedFromRange","useCallback","winSelection","rangeCount","getRangeAt","intersectsNode","onBlur","onFocus","onSelection","unsubscribe","content","returnedChildren","Text","isText","span","forEach","annotation","t","_child","createWithHotkeys","hotkeysFromOptions","reservedHotkeys","activeHotkeys","pteWithHotKeys","keys","cat","hotkey","isHotkey","preventDefault","possibleMark","behaviorEvent","decorator","possibleCommand","command","withSyncRangeDecorations","syncRangeDecorations","originalApply","apply","op","matches","PLACEHOLDER_STYLE","pointerEvents","right","PortableTextEditable","forwardRef","forwardedRef","hotkeys","onBeforeInput","onPaste","onCopy","onCut","onClick","onDrag","onDragEnter","onDragOver","onDrop","onDragLeave","rangeDecorations","renderPlaceholder","propsSelection","scrollSelectionIntoView","restProps","ref","editableElement","setEditableElement","hasInvalidValue","setHasInvalidValue","rangeDecorationState","setRangeDecorationsState","rangeDecorationsRef","useSelector","s","useSlate","blockTypeName","withHotKeys","renderElement","eProps","renderLeaf","lProps","rendered","placeholder","decoration","rangeDecoration","component","restoreSelectionFromProps","JSON","stringify","normalizedSelection","slateRange","Transforms","select","operations","o","onChange","operation","newSlateRanges","rangeDecorationItem","SlateRange","isRange","onMoved","newSelection","newRange","moveRangeByOperation","getValue","newRangeSelection","onReady","onInvalidValue","onValueChanged","syncedRangeDecorations","setSyncedRangeDecorations","teardown","handleCopy","clipboardData","stopPropagation","originEvent","handleCut","handlePaste","onPasteResult","Promise","resolve","then","result","insert","blocks","parseBlocks","keyGenerator","options","refreshKeys","placement","catch","finally","handleOnFocus","isDefaultPrevented","start","handleClick","isPropagationStopped","handleOnBlur","handleOnBeforeInput","validateSelection","root","findDocumentOrShadowRoot","activeElement","domSelection","existingDOMRange","newDOMRange","toDOMRange","startOffset","endOffset","removeAllRanges","addRange","deselect","mutationObserver","MutationObserver","observe","attributeOldValue","characterData","childList","subtree","disconnect","handleKeyDown","onKeyDown","key","code","altKey","ctrlKey","metaKey","shiftKey","handleKeyUp","onKeyUp","scrollSelectionIntoViewToSlate","noop","_editor","decorate","isEqualToEmptyEditor","Path","equals","intersection","addEventListener","removeEventListener","isVoid","void","at","voids","handleDrag","handleDragEnter","handleDragOver","handleDrop","findEventRange","handleDragLeave","SlateEditable","EditorEventListener","useEditor","useEffectEvent","subscription"],"mappings":"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"}