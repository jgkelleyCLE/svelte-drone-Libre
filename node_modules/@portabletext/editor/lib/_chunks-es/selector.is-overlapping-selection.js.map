{"version":3,"file":"selector.is-overlapping-selection.js","sources":["../../src/selectors/selector.is-selecting-entire-blocks.ts","../../src/selectors/selector.get-selected-spans.ts","../../src/selectors/selector.get-active-list-item.ts","../../src/selectors/selector.get-active-style.ts","../../src/selectors/selector.get-trimmed-selection.ts","../../src/selectors/selector.is-active-annotation.ts","../../src/selectors/selector.is-active-decorator.ts","../../src/selectors/selector.is-active-list-item.ts","../../src/selectors/selector.is-active-style.ts","../../src/selectors/selector.is-point-after-selection.ts","../../src/selectors/selector.is-point-before-selection.ts","../../src/selectors/selector.is-overlapping-selection.ts"],"sourcesContent":["import type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {getSelectionEndBlock, getSelectionStartBlock} from './selectors'\n\n/**\n * @public\n */\nexport const isSelectingEntireBlocks: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlock = getSelectionStartBlock(snapshot)\n  const endBlock = getSelectionEndBlock(snapshot)\n\n  if (!startBlock || !endBlock) {\n    return false\n  }\n\n  const startBlockStartPoint = utils.getBlockStartPoint(startBlock)\n  const endBlockEndPoint = utils.getBlockEndPoint(endBlock)\n\n  return (\n    utils.isEqualSelectionPoints(startBlockStartPoint, startPoint) &&\n    utils.isEqualSelectionPoints(endBlockEndPoint, endPoint)\n  )\n}\n","import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextSpan,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedSpans: Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }> = []\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlockKey = isKeySegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : undefined\n  const endBlockKey = isKeySegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : undefined\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedSpans\n  }\n\n  const startSpanKey = isKeySegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : undefined\n  const endSpanKey = isKeySegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : undefined\n\n  for (const block of snapshot.context.value) {\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    if (block._key === startBlockKey) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        if (startSpanKey && child._key === startSpanKey) {\n          if (startPoint.offset < child.text.length) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n\n          if (startSpanKey === endSpanKey) {\n            break\n          }\n\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        if (selectedSpans.length > 0) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n        }\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n\n      break\n    }\n\n    if (selectedSpans.length > 0) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n    }\n  }\n\n  return selectedSpans\n}\n","import type {PortableTextListBlock} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const guards = createGuards(snapshot.context)\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter(guards.isTextBlock)\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const guards = createGuards(snapshot.context)\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter(guards.isTextBlock)\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextSpan,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\nimport {isEmptyTextBlock, isKeyedSegment} from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getTrimmedSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return snapshot.context.selection\n  }\n\n  const startPoint = getSelectionStartPoint(snapshot)\n  const endPoint = getSelectionEndPoint(snapshot)\n\n  if (!startPoint || !endPoint) {\n    return snapshot.context.selection\n  }\n\n  const startBlockKey = isKeyedSegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : null\n  const startChildKey = isKeyedSegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : null\n  const endBlockKey = isKeyedSegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : null\n  const endChildKey = isKeyedSegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : null\n\n  if (!startBlockKey || !endBlockKey) {\n    return snapshot.context.selection\n  }\n\n  let startBlockFound = false\n  let adjustedStartPoint: EditorSelectionPoint | undefined\n  let trimStartPoint = false\n  let adjustedEndPoint: EditorSelectionPoint | undefined\n  let trimEndPoint = false\n  let previousPotentialEndpoint:\n    | {blockKey: string; span: PortableTextSpan}\n    | undefined\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n\n      if (isPortableTextTextBlock(block) && isEmptyTextBlock(block)) {\n        continue\n      }\n    }\n\n    if (!startBlockFound) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    if (block._key === endBlockKey && isEmptyTextBlock(block)) {\n      break\n    }\n\n    for (const child of block.children) {\n      if (child._key === endChildKey) {\n        if (!isPortableTextSpan(child) || endPoint.offset === 0) {\n          adjustedEndPoint = previousPotentialEndpoint\n            ? {\n                path: [\n                  {_key: previousPotentialEndpoint.blockKey},\n                  'children',\n                  {_key: previousPotentialEndpoint.span._key},\n                ],\n                offset: previousPotentialEndpoint.span.text.length,\n              }\n            : undefined\n\n          trimEndPoint = true\n          break\n        }\n      }\n\n      if (trimStartPoint) {\n        const lonelySpan =\n          isPortableTextSpan(child) && block.children.length === 1\n\n        if (\n          (isPortableTextSpan(child) && child.text.length > 0) ||\n          lonelySpan\n        ) {\n          adjustedStartPoint = {\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n            offset: 0,\n          }\n          previousPotentialEndpoint = {blockKey: block._key, span: child}\n          trimStartPoint = false\n        }\n\n        continue\n      }\n\n      if (child._key === startChildKey) {\n        if (!isPortableTextSpan(child)) {\n          trimStartPoint = true\n          continue\n        }\n\n        if (startPoint.offset === child.text.length) {\n          trimStartPoint = true\n          previousPotentialEndpoint =\n            child.text.length > 0\n              ? {blockKey: block._key, span: child}\n              : previousPotentialEndpoint\n          continue\n        }\n      }\n\n      previousPotentialEndpoint =\n        isPortableTextSpan(child) && child.text.length > 0\n          ? {blockKey: block._key, span: child}\n          : previousPotentialEndpoint\n    }\n\n    if (block._key === endBlockKey) {\n      break\n    }\n  }\n\n  const trimmedSelection = snapshot.context.selection.backward\n    ? {\n        anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n        focus: adjustedStartPoint ?? startPoint,\n        backward: true,\n      }\n    : {\n        anchor: adjustedStartPoint ?? startPoint,\n        focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n      }\n\n  if (\n    isSelectionCollapsed({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n  ) {\n    const focusTextBlock = getFocusTextBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n\n    if (focusTextBlock && !isEmptyTextBlock(focusTextBlock.node)) {\n      return null\n    }\n  }\n\n  return trimmedSelection\n}\n","import {isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\nimport {getFocusSpan, getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const focusSpan = getFocusSpan(snapshot)\n\n    const selectedSpans = isSelectionExpanded(snapshot)\n      ? getSelectedSpans(snapshot)\n      : focusSpan\n        ? [focusSpan]\n        : []\n\n    if (selectedSpans.length === 0) {\n      return false\n    }\n\n    if (\n      selectedSpans.some(\n        (span) => !span.node.marks || span.node.marks?.length === 0,\n      )\n    ) {\n      return false\n    }\n\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isPortableTextTextBlock(block.node) ? (block.node.markDefs ?? []) : [],\n    )\n\n    return selectedSpans.every((span) => {\n      const spanMarkDefs =\n        span.node.marks?.flatMap((mark) => {\n          const markDef = selectionMarkDefs.find(\n            (markDef) => markDef._key === mark,\n          )\n\n          return markDef ? [markDef._type] : []\n        }) ?? []\n\n      return spanMarkDefs.includes(annotation)\n    })\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    return snapshot.context.activeDecorators.includes(decorator)\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n","import {isKeySegment, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = snapshot.context.selection.backward\n      ? reverseSelection(snapshot.context.selection)\n      : snapshot.context.selection\n\n    const pointBlockKey = isKeySegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeySegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const endBlockKey = isKeySegment(selection.focus.path[0])\n      ? selection.focus.path[0]._key\n      : undefined\n    const endChildKey = isKeySegment(selection.focus.path[2])\n      ? selection.focus.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !endBlockKey) {\n      return false\n    }\n\n    let after = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === endBlockKey) {\n        if (block._key !== pointBlockKey) {\n          after = true\n          break\n        }\n\n        // Both the point and the selection end in this block\n\n        if (!isPortableTextTextBlock(block)) {\n          break\n        }\n\n        if (!pointChildKey || !endChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === endChildKey) {\n            if (child._key !== pointChildKey) {\n              after = true\n              break\n            }\n\n            // Both the point and the selection end in this child\n\n            after = point.offset > selection.focus.offset\n            break\n          }\n\n          if (child._key === pointChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === pointBlockKey) {\n        break\n      }\n    }\n\n    return after\n  }\n}\n","import {isKeySegment, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = snapshot.context.selection.backward\n      ? reverseSelection(snapshot.context.selection)\n      : snapshot.context.selection\n\n    const pointBlockKey = isKeySegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeySegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const startBlockKey = isKeySegment(selection.anchor.path[0])\n      ? selection.anchor.path[0]._key\n      : undefined\n    const startChildKey = isKeySegment(selection.anchor.path[2])\n      ? selection.anchor.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !startBlockKey) {\n      return false\n    }\n\n    let before = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === pointBlockKey) {\n        if (block._key !== startBlockKey) {\n          before = true\n          break\n        }\n\n        // Both the point and the selection start in this block\n\n        if (!isPortableTextTextBlock(block)) {\n          break\n        }\n\n        if (!pointChildKey || !startChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === pointChildKey) {\n            if (child._key !== startChildKey) {\n              before = true\n              break\n            }\n\n            // Both the point and the selection start in this child\n\n            before = point.offset < selection.anchor.offset\n            break\n          }\n\n          if (child._key === startChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === startBlockKey) {\n        break\n      }\n    }\n\n    return before\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualSelectionPoints} from '../utils'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isPointAfterSelection} from './selector.is-point-after-selection'\nimport {isPointBeforeSelection} from './selector.is-point-before-selection'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!selection || !snapshot.context.selection) {\n      return false\n    }\n\n    const selectionStartPoint = getSelectionStartPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n    const selectionEndPoint = getSelectionEndPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    const originalSelectionStartPoint = getSelectionStartPoint(snapshot)\n    const originalSelectionEndPoint = getSelectionEndPoint(snapshot)\n\n    if (\n      !selectionStartPoint ||\n      !selectionEndPoint ||\n      !originalSelectionStartPoint ||\n      !originalSelectionEndPoint\n    ) {\n      return false\n    }\n\n    const startPointBeforeSelection =\n      isPointBeforeSelection(selectionStartPoint)(snapshot)\n    const startPointAfterSelection =\n      isPointAfterSelection(selectionStartPoint)(snapshot)\n    const endPointBeforeSelection =\n      isPointBeforeSelection(selectionEndPoint)(snapshot)\n    const endPointAfterSelection =\n      isPointAfterSelection(selectionEndPoint)(snapshot)\n\n    const originalStartPointBeforeStartPoint = isPointBeforeSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n    const originalStartPointAfterStartPoint = isPointAfterSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n\n    const originalEndPointBeforeEndPoint = isPointBeforeSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n    const originalEndPointAfterEndPoint = isPointAfterSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n\n    const endPointEqualToOriginalStartPoint = isEqualSelectionPoints(\n      selectionEndPoint,\n      originalSelectionStartPoint,\n    )\n    const startPointEqualToOriginalEndPoint = isEqualSelectionPoints(\n      selectionStartPoint,\n      originalSelectionEndPoint,\n    )\n\n    if (endPointBeforeSelection && !endPointEqualToOriginalStartPoint) {\n      return false\n    }\n\n    if (startPointAfterSelection && !startPointEqualToOriginalEndPoint) {\n      return false\n    }\n\n    if (\n      !originalStartPointBeforeStartPoint &&\n      originalStartPointAfterStartPoint &&\n      !originalEndPointBeforeEndPoint &&\n      originalEndPointAfterEndPoint\n    ) {\n      return !endPointEqualToOriginalStartPoint\n    }\n\n    if (\n      originalStartPointBeforeStartPoint &&\n      !originalStartPointAfterStartPoint &&\n      originalEndPointBeforeEndPoint &&\n      !originalEndPointAfterEndPoint\n    ) {\n      return !startPointEqualToOriginalEndPoint\n    }\n\n    if (\n      !startPointAfterSelection ||\n      !startPointBeforeSelection ||\n      !endPointAfterSelection ||\n      !endPointBeforeSelection\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n"],"names":["isSelectingEntireBlocks","snapshot","context","selection","startPoint","backward","focus","anchor","endPoint","startBlock","getSelectionStartBlock","endBlock","getSelectionEndBlock","startBlockStartPoint","utils","endBlockEndPoint","getSelectedSpans","selectedSpans","startBlockKey","isKeySegment","path","_key","undefined","endBlockKey","startSpanKey","endSpanKey","block","value","isPortableTextTextBlock","child","children","isPortableTextSpan","offset","text","length","push","node","getActiveListItem","guards","createGuards","selectedTextBlocks","getSelectedBlocks","map","filter","isTextBlock","firstTextBlock","at","firstListItem","listItem","every","getActiveStyle","firstStyle","style","getTrimmedSelection","getSelectionStartPoint","getSelectionEndPoint","isKeyedSegment","startChildKey","endChildKey","startBlockFound","adjustedStartPoint","trimStartPoint","adjustedEndPoint","trimEndPoint","previousPotentialEndpoint","isEmptyTextBlock","blockKey","span","lonelySpan","trimmedSelection","isSelectionCollapsed","focusTextBlock","getFocusTextBlock","isActiveAnnotation","annotation","selectedBlocks","focusSpan","getFocusSpan","isSelectionExpanded","some","marks","selectionMarkDefs","flatMap","markDefs","mark","markDef","find","_type","includes","isActiveDecorator","decorator","activeDecorators","isActiveListItem","isActiveStyle","isPointAfterSelection","point","reverseSelection","pointBlockKey","pointChildKey","after","isPointBeforeSelection","before","isOverlappingSelection","selectionStartPoint","selectionEndPoint","originalSelectionStartPoint","originalSelectionEndPoint","startPointBeforeSelection","startPointAfterSelection","endPointBeforeSelection","endPointAfterSelection","originalStartPointBeforeStartPoint","originalStartPointAfterStartPoint","originalEndPointBeforeEndPoint","originalEndPointAfterEndPoint","endPointEqualToOriginalStartPoint","isEqualSelectionPoints","startPointEqualToOriginalEndPoint"],"mappings":"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"}